import { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types';
/**
  Implements the BIRCH clustering algorithm.

  It is a memory-efficient, online-learning algorithm provided as an alternative to [`MiniBatchKMeans`](sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans "sklearn.cluster.MiniBatchKMeans"). It constructs a tree data structure with the cluster centroids being read off the leaf. These can be either the final cluster centroids or can be provided as input to another clustering algorithm such as [`AgglomerativeClustering`](sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering "sklearn.cluster.AgglomerativeClustering").

  Read more in the [User Guide](../clustering.html#birch).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Birch.html)
 */
export declare class Birch {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          The radius of the subcluster obtained by merging a new sample and the closest subcluster should be lesser than the threshold. Otherwise a new subcluster is started. Setting this value to be very low promotes splitting and vice-versa.
    
          @defaultValue `0.5`
         */
        threshold?: number;
        /**
          Maximum number of CF subclusters in each node. If a new samples enters such that the number of subclusters exceed the branching\_factor then that node is split into two nodes with the subclusters redistributed in each. The parent subcluster of that node is removed and two new subclusters are added as parents of the 2 split nodes.
    
          @defaultValue `50`
         */
        branching_factor?: number;
        /**
          Number of clusters after the final clustering step, which treats the subclusters from the leaves as new samples.
    
          @defaultValue `3`
         */
        n_clusters?: number;
        /**
          Whether or not to compute labels for each fit.
    
          @defaultValue `true`
         */
        compute_labels?: boolean;
        /**
          Whether or not to make a copy of the given data. If set to `false`, the initial data will be overwritten.
    
          @defaultValue `true`
         */
        copy?: boolean;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Build a CF Tree for the input data.
     */
    fit(opts: {
        /**
          Input data.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
    }): Promise<any>;
    /**
      Perform clustering on `X` and returns cluster labels.
     */
    fit_predict(opts: {
        /**
          Input data.
         */
        X?: ArrayLike[];
        /**
          Not used, present for API consistency by convention.
         */
        y?: any;
    }): Promise<NDArray>;
    /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit\_params` and returns a transformed version of `X`.
     */
    fit_transform(opts: {
        /**
          Input samples.
         */
        X?: ArrayLike[];
        /**
          Target values (`undefined` for unsupervised transformations).
         */
        y?: ArrayLike;
        /**
          Additional fit parameters.
         */
        fit_params?: any;
    }): Promise<any[]>;
    /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class\_name0", "class\_name1", "class\_name2"\]`.
     */
    get_feature_names_out(opts: {
        /**
          Only used to validate feature names with the names seen in [`fit`](#sklearn.cluster.Birch.fit "sklearn.cluster.Birch.fit").
         */
        input_features?: any;
    }): Promise<any>;
    /**
      Online learning. Prevents rebuilding of CFTree from scratch.
     */
    partial_fit(opts: {
        /**
          Input data. If X is not provided, only the global clustering step is done.
         */
        X?: ArrayLike | SparseMatrix[];
        /**
          Not used, present here for API consistency by convention.
         */
        y?: any;
    }): Promise<any>;
    /**
      Predict data using the `centroids\_` of subclusters.
  
      Avoid computation of the row norms of X.
     */
    predict(opts: {
        /**
          Input data.
         */
        X?: ArrayLike | SparseMatrix[];
    }): Promise<any>;
    /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
    set_output(opts: {
        /**
          Configure output of `transform` and `fit\_transform`.
         */
        transform?: 'default' | 'pandas';
    }): Promise<any>;
    /**
      Transform X into subcluster centroids dimension.
  
      Each dimension represents the distance from the sample point to each cluster centroid.
     */
    transform(opts: {
        /**
          Input data.
         */
        X?: ArrayLike | SparseMatrix[];
    }): Promise<ArrayLike | SparseMatrix[]>;
    /**
      Root of the CFTree.
     */
    get root_(): Promise<any>;
    /**
      Start pointer to all the leaves.
     */
    get dummy_leaf_(): Promise<any>;
    /**
      Centroids of all subclusters read directly from the leaves.
     */
    get subcluster_centers_(): Promise<NDArray>;
    /**
      Labels assigned to the centroids of the subclusters after they are clustered globally.
     */
    get subcluster_labels_(): Promise<NDArray>;
    /**
      Array of labels assigned to the input data. if partial\_fit is used instead of fit, they are assigned to the last batch of data.
     */
    get labels_(): Promise<NDArray>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=Birch.d.ts.map