{"version":3,"sources":["../../../src/generated/cluster/SpectralBiclustering.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Spectral biclustering (Kluger, 2003).\n\n  Partitions rows and columns under the assumption that the data has an underlying checkerboard structure. For instance, if there are two row partitions and three column partitions, each row will belong to three biclusters, and each column will belong to two biclusters. The outer product of the corresponding row and column label vectors gives this checkerboard structure.\n\n  Read more in the [User Guide](../biclustering.html#spectral-biclustering).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralBiclustering.html)\n */\nexport class SpectralBiclustering {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The number of row and column clusters in the checkerboard structure.\n\n      @defaultValue `3`\n     */\n    n_clusters?: number\n\n    /**\n      Method of normalizing and converting singular vectors into biclusters. May be one of ‘scale’, ‘bistochastic’, or ‘log’. The authors recommend using ‘log’. If the data is sparse, however, log normalization will not work, which is why the default is ‘bistochastic’.\n\n      @defaultValue `'bistochastic'`\n     */\n    method?: 'bistochastic' | 'scale' | 'log'\n\n    /**\n      Number of singular vectors to check.\n\n      @defaultValue `6`\n     */\n    n_components?: number\n\n    /**\n      Number of best singular vectors to which to project the data for clustering.\n\n      @defaultValue `3`\n     */\n    n_best?: number\n\n    /**\n      Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, uses [`randomized\\_svd`](sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd \"sklearn.utils.extmath.randomized_svd\"), which may be faster for large matrices. If ‘arpack’, uses `scipy.sparse.linalg.svds`, which is more accurate, but possibly slower in some cases.\n\n      @defaultValue `'randomized'`\n     */\n    svd_method?: 'randomized' | 'arpack'\n\n    /**\n      Number of vectors to use in calculating the SVD. Corresponds to `ncv` when `svd\\_method=arpack` and `n\\_oversamples` when `svd\\_method` is ‘randomized\\`.\n     */\n    n_svd_vecs?: number\n\n    /**\n      Whether to use mini-batch k-means, which is faster but may get different results.\n\n      @defaultValue `false`\n     */\n    mini_batch?: boolean\n\n    /**\n      Method for initialization of k-means algorithm; defaults to ‘k-means++’.\n\n      @defaultValue `'k-means++'`\n     */\n    init?: 'k-means++' | 'random' | NDArray[]\n\n    /**\n      Number of random initializations that are tried with the k-means algorithm.\n\n      If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen.\n\n      @defaultValue `10`\n     */\n    n_init?: number\n\n    /**\n      Used for randomizing the singular value decomposition and the k-means initialization. Use an int to make the randomness deterministic. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `SpectralBiclustering${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'SpectralBiclustering.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.cluster import SpectralBiclustering\ntry: bridgeSpectralBiclustering\nexcept NameError: bridgeSpectralBiclustering = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_SpectralBiclustering = {'n_clusters': ${\n      this.opts['n_clusters'] ?? undefined\n    }, 'method': ${this.opts['method'] ?? undefined}, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'n_best': ${this.opts['n_best'] ?? undefined}, 'svd_method': ${\n      this.opts['svd_method'] ?? undefined\n    }, 'n_svd_vecs': ${this.opts['n_svd_vecs'] ?? undefined}, 'mini_batch': ${\n      this.opts['mini_batch'] ?? undefined\n    }, 'init': np.array(${this.opts['init'] ?? undefined}) if ${\n      this.opts['init'] !== undefined\n    } else None, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}}\n\nctor_SpectralBiclustering = {k: v for k, v in ctor_SpectralBiclustering.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeSpectralBiclustering[${this.id}] = SpectralBiclustering(**ctor_SpectralBiclustering)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeSpectralBiclustering[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Create a biclustering for X.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('SpectralBiclustering must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_SpectralBiclustering_fit = {k: v for k, v in pms_SpectralBiclustering_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_fit = bridgeSpectralBiclustering[${this.id}].fit(**pms_SpectralBiclustering_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_fit.tolist() if hasattr(res_SpectralBiclustering_fit, 'tolist') else res_SpectralBiclustering_fit`\n  }\n\n  /**\n    Row and column indices of the `i`’th bicluster.\n\n    Only works if `rows\\_` and `columns\\_` attributes exist.\n   */\n  async get_indices(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_indices()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_get_indices = {'i': ${\n      opts['i'] ?? undefined\n    }}\n\npms_SpectralBiclustering_get_indices = {k: v for k, v in pms_SpectralBiclustering_get_indices.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_indices = bridgeSpectralBiclustering[${this.id}].get_indices(**pms_SpectralBiclustering_get_indices)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_indices.tolist() if hasattr(res_SpectralBiclustering_get_indices, 'tolist') else res_SpectralBiclustering_get_indices`\n  }\n\n  /**\n    Shape of the `i`’th bicluster.\n   */\n  async get_shape(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_shape()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_get_shape = {'i': ${\n      opts['i'] ?? undefined\n    }}\n\npms_SpectralBiclustering_get_shape = {k: v for k, v in pms_SpectralBiclustering_get_shape.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_shape = bridgeSpectralBiclustering[${this.id}].get_shape(**pms_SpectralBiclustering_get_shape)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_shape.tolist() if hasattr(res_SpectralBiclustering_get_shape, 'tolist') else res_SpectralBiclustering_get_shape`\n  }\n\n  /**\n    Return the submatrix corresponding to bicluster `i`.\n   */\n  async get_submatrix(opts: {\n    /**\n      The index of the cluster.\n     */\n    i?: number\n\n    /**\n      The data.\n     */\n    data?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before get_submatrix()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_SpectralBiclustering_get_submatrix = {'i': ${\n      opts['i'] ?? undefined\n    }, 'data': np.array(${opts['data'] ?? undefined}) if ${\n      opts['data'] !== undefined\n    } else None}\n\npms_SpectralBiclustering_get_submatrix = {k: v for k, v in pms_SpectralBiclustering_get_submatrix.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_SpectralBiclustering_get_submatrix = bridgeSpectralBiclustering[${this.id}].get_submatrix(**pms_SpectralBiclustering_get_submatrix)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_SpectralBiclustering_get_submatrix.tolist() if hasattr(res_SpectralBiclustering_get_submatrix, 'tolist') else res_SpectralBiclustering_get_submatrix`\n  }\n\n  /**\n    Results of the clustering. `rows\\[i, r\\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.\n   */\n  get rows_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing rows_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_rows_ = bridgeSpectralBiclustering[${this.id}].rows_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_rows_.tolist() if hasattr(attr_SpectralBiclustering_rows_, 'tolist') else attr_SpectralBiclustering_rows_`\n    })()\n  }\n\n  /**\n    Results of the clustering, like `rows`.\n   */\n  get columns_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing columns_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_columns_ = bridgeSpectralBiclustering[${this.id}].columns_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_columns_.tolist() if hasattr(attr_SpectralBiclustering_columns_, 'tolist') else attr_SpectralBiclustering_columns_`\n    })()\n  }\n\n  /**\n    Row partition labels.\n   */\n  get row_labels_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing row_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_row_labels_ = bridgeSpectralBiclustering[${this.id}].row_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_row_labels_.tolist() if hasattr(attr_SpectralBiclustering_row_labels_, 'tolist') else attr_SpectralBiclustering_row_labels_`\n    })()\n  }\n\n  /**\n    Column partition labels.\n   */\n  get column_labels_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing column_labels_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_column_labels_ = bridgeSpectralBiclustering[${this.id}].column_labels_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_column_labels_.tolist() if hasattr(attr_SpectralBiclustering_column_labels_, 'tolist') else attr_SpectralBiclustering_column_labels_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_n_features_in_ = bridgeSpectralBiclustering[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_n_features_in_.tolist() if hasattr(attr_SpectralBiclustering_n_features_in_, 'tolist') else attr_SpectralBiclustering_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This SpectralBiclustering instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'SpectralBiclustering must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_SpectralBiclustering_feature_names_in_ = bridgeSpectralBiclustering[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_SpectralBiclustering_feature_names_in_.tolist() if hasattr(attr_SpectralBiclustering_feature_names_in_, 'tolist') else attr_SpectralBiclustering_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}