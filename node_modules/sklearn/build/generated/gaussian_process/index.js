// src/generated/gaussian_process/GaussianProcessClassifier.ts
import crypto from "node:crypto";
var GaussianProcessClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianProcessClassifier${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GaussianProcessClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process import GaussianProcessClassifier
try: bridgeGaussianProcessClassifier
except NameError: bridgeGaussianProcessClassifier = {}
`;
    await this._py.ex`ctor_GaussianProcessClassifier = {'kernel': ${this.opts["kernel"] ?? void 0}, 'optimizer': ${this.opts["optimizer"] ?? void 0}, 'n_restarts_optimizer': ${this.opts["n_restarts_optimizer"] ?? void 0}, 'max_iter_predict': ${this.opts["max_iter_predict"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'copy_X_train': ${this.opts["copy_X_train"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_GaussianProcessClassifier = {k: v for k, v in ctor_GaussianProcessClassifier.items() if v is not None}`;
    await this._py.ex`bridgeGaussianProcessClassifier[${this.id}] = GaussianProcessClassifier(**ctor_GaussianProcessClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianProcessClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Gaussian process classification model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GaussianProcessClassifier must call init() before fit()");
    }
    await this._py.ex`pms_GaussianProcessClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GaussianProcessClassifier_fit = {k: v for k, v in pms_GaussianProcessClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_fit = bridgeGaussianProcessClassifier[${this.id}].fit(**pms_GaussianProcessClassifier_fit)`;
    return this._py`res_GaussianProcessClassifier_fit.tolist() if hasattr(res_GaussianProcessClassifier_fit, 'tolist') else res_GaussianProcessClassifier_fit`;
  }
  /**
      Return log-marginal likelihood of theta for training data.
  
      In the case of multi-class classification, the mean log-marginal likelihood of the one-versus-rest classifiers are returned.
     */
  async log_marginal_likelihood(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before log_marginal_likelihood()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_log_marginal_likelihood = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}, 'clone_kernel': ${opts["clone_kernel"] ?? void 0}}

pms_GaussianProcessClassifier_log_marginal_likelihood = {k: v for k, v in pms_GaussianProcessClassifier_log_marginal_likelihood.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_log_marginal_likelihood = bridgeGaussianProcessClassifier[${this.id}].log_marginal_likelihood(**pms_GaussianProcessClassifier_log_marginal_likelihood)`;
    return this._py`res_GaussianProcessClassifier_log_marginal_likelihood.tolist() if hasattr(res_GaussianProcessClassifier_log_marginal_likelihood, 'tolist') else res_GaussianProcessClassifier_log_marginal_likelihood`;
  }
  /**
    Perform classification on an array of test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianProcessClassifier_predict = {k: v for k, v in pms_GaussianProcessClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_predict = bridgeGaussianProcessClassifier[${this.id}].predict(**pms_GaussianProcessClassifier_predict)`;
    return this._py`res_GaussianProcessClassifier_predict.tolist() if hasattr(res_GaussianProcessClassifier_predict, 'tolist') else res_GaussianProcessClassifier_predict`;
  }
  /**
    Return probability estimates for the test vector X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianProcessClassifier_predict_proba = {k: v for k, v in pms_GaussianProcessClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_predict_proba = bridgeGaussianProcessClassifier[${this.id}].predict_proba(**pms_GaussianProcessClassifier_predict_proba)`;
    return this._py`res_GaussianProcessClassifier_predict_proba.tolist() if hasattr(res_GaussianProcessClassifier_predict_proba, 'tolist') else res_GaussianProcessClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_GaussianProcessClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianProcessClassifier_score = {k: v for k, v in pms_GaussianProcessClassifier_score.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessClassifier_score = bridgeGaussianProcessClassifier[${this.id}].score(**pms_GaussianProcessClassifier_score)`;
    return this._py`res_GaussianProcessClassifier_score.tolist() if hasattr(res_GaussianProcessClassifier_score, 'tolist') else res_GaussianProcessClassifier_score`;
  }
  /**
    The estimator instance that defines the likelihood function using the observed data.
   */
  get base_estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing base_estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_base_estimator_ = bridgeGaussianProcessClassifier[${this.id}].base_estimator_`;
      return this._py`attr_GaussianProcessClassifier_base_estimator_.tolist() if hasattr(attr_GaussianProcessClassifier_base_estimator_, 'tolist') else attr_GaussianProcessClassifier_base_estimator_`;
    })();
  }
  /**
    The log-marginal-likelihood of `self.kernel\_.theta`
   */
  get log_marginal_likelihood_value_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing log_marginal_likelihood_value_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_log_marginal_likelihood_value_ = bridgeGaussianProcessClassifier[${this.id}].log_marginal_likelihood_value_`;
      return this._py`attr_GaussianProcessClassifier_log_marginal_likelihood_value_.tolist() if hasattr(attr_GaussianProcessClassifier_log_marginal_likelihood_value_, 'tolist') else attr_GaussianProcessClassifier_log_marginal_likelihood_value_`;
    })();
  }
  /**
    Unique class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_classes_ = bridgeGaussianProcessClassifier[${this.id}].classes_`;
      return this._py`attr_GaussianProcessClassifier_classes_.tolist() if hasattr(attr_GaussianProcessClassifier_classes_, 'tolist') else attr_GaussianProcessClassifier_classes_`;
    })();
  }
  /**
    The number of classes in the training data
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_n_classes_ = bridgeGaussianProcessClassifier[${this.id}].n_classes_`;
      return this._py`attr_GaussianProcessClassifier_n_classes_.tolist() if hasattr(attr_GaussianProcessClassifier_n_classes_, 'tolist') else attr_GaussianProcessClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_n_features_in_ = bridgeGaussianProcessClassifier[${this.id}].n_features_in_`;
      return this._py`attr_GaussianProcessClassifier_n_features_in_.tolist() if hasattr(attr_GaussianProcessClassifier_n_features_in_, 'tolist') else attr_GaussianProcessClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessClassifier_feature_names_in_ = bridgeGaussianProcessClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianProcessClassifier_feature_names_in_.tolist() if hasattr(attr_GaussianProcessClassifier_feature_names_in_, 'tolist') else attr_GaussianProcessClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/gaussian_process/GaussianProcessRegressor.ts
import crypto2 from "node:crypto";
var GaussianProcessRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianProcessRegressor${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GaussianProcessRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
try: bridgeGaussianProcessRegressor
except NameError: bridgeGaussianProcessRegressor = {}
`;
    await this._py.ex`ctor_GaussianProcessRegressor = {'kernel': ${this.opts["kernel"] ?? void 0}, 'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'optimizer': ${this.opts["optimizer"] ?? void 0}, 'n_restarts_optimizer': ${this.opts["n_restarts_optimizer"] ?? void 0}, 'normalize_y': ${this.opts["normalize_y"] ?? void 0}, 'copy_X_train': ${this.opts["copy_X_train"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_GaussianProcessRegressor = {k: v for k, v in ctor_GaussianProcessRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGaussianProcessRegressor[${this.id}] = GaussianProcessRegressor(**ctor_GaussianProcessRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianProcessRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Gaussian process regression model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GaussianProcessRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GaussianProcessRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GaussianProcessRegressor_fit = {k: v for k, v in pms_GaussianProcessRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_fit = bridgeGaussianProcessRegressor[${this.id}].fit(**pms_GaussianProcessRegressor_fit)`;
    return this._py`res_GaussianProcessRegressor_fit.tolist() if hasattr(res_GaussianProcessRegressor_fit, 'tolist') else res_GaussianProcessRegressor_fit`;
  }
  /**
    Return log-marginal likelihood of theta for training data.
   */
  async log_marginal_likelihood(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before log_marginal_likelihood()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_log_marginal_likelihood = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}, 'clone_kernel': ${opts["clone_kernel"] ?? void 0}}

pms_GaussianProcessRegressor_log_marginal_likelihood = {k: v for k, v in pms_GaussianProcessRegressor_log_marginal_likelihood.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_log_marginal_likelihood = bridgeGaussianProcessRegressor[${this.id}].log_marginal_likelihood(**pms_GaussianProcessRegressor_log_marginal_likelihood)`;
    return this._py`res_GaussianProcessRegressor_log_marginal_likelihood.tolist() if hasattr(res_GaussianProcessRegressor_log_marginal_likelihood, 'tolist') else res_GaussianProcessRegressor_log_marginal_likelihood`;
  }
  /**
      Predict using the Gaussian process regression model.
  
      We can also predict based on an unfitted model by using the GP prior. In addition to the mean of the predictive distribution, optionally also returns its standard deviation (`return\_std=True`) or covariance (`return\_cov=True`). Note that at most one of the two can be requested.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}, 'return_cov': ${opts["return_cov"] ?? void 0}}

pms_GaussianProcessRegressor_predict = {k: v for k, v in pms_GaussianProcessRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_predict = bridgeGaussianProcessRegressor[${this.id}].predict(**pms_GaussianProcessRegressor_predict)`;
    return this._py`res_GaussianProcessRegressor_predict.tolist() if hasattr(res_GaussianProcessRegressor_predict, 'tolist') else res_GaussianProcessRegressor_predict`;
  }
  /**
    Draw samples from Gaussian process and evaluate at X.
   */
  async sample_y(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before sample_y()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_sample_y = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_samples': ${opts["n_samples"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}}

pms_GaussianProcessRegressor_sample_y = {k: v for k, v in pms_GaussianProcessRegressor_sample_y.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_sample_y = bridgeGaussianProcessRegressor[${this.id}].sample_y(**pms_GaussianProcessRegressor_sample_y)`;
    return this._py`res_GaussianProcessRegressor_sample_y.tolist() if hasattr(res_GaussianProcessRegressor_sample_y, 'tolist') else res_GaussianProcessRegressor_sample_y`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianProcessRegressor_score = {k: v for k, v in pms_GaussianProcessRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_score = bridgeGaussianProcessRegressor[${this.id}].score(**pms_GaussianProcessRegressor_score)`;
    return this._py`res_GaussianProcessRegressor_score.tolist() if hasattr(res_GaussianProcessRegressor_score, 'tolist') else res_GaussianProcessRegressor_score`;
  }
  /**
    Feature vectors or other representations of training data (also required for prediction).
   */
  get X_train_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing X_train_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_X_train_ = bridgeGaussianProcessRegressor[${this.id}].X_train_`;
      return this._py`attr_GaussianProcessRegressor_X_train_.tolist() if hasattr(attr_GaussianProcessRegressor_X_train_, 'tolist') else attr_GaussianProcessRegressor_X_train_`;
    })();
  }
  /**
    Target values in training data (also required for prediction).
   */
  get y_train_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing y_train_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_y_train_ = bridgeGaussianProcessRegressor[${this.id}].y_train_`;
      return this._py`attr_GaussianProcessRegressor_y_train_.tolist() if hasattr(attr_GaussianProcessRegressor_y_train_, 'tolist') else attr_GaussianProcessRegressor_y_train_`;
    })();
  }
  /**
    The kernel used for prediction. The structure of the kernel is the same as the one passed as parameter but with optimized hyperparameters.
   */
  get kernel_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing kernel_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_kernel_ = bridgeGaussianProcessRegressor[${this.id}].kernel_`;
      return this._py`attr_GaussianProcessRegressor_kernel_.tolist() if hasattr(attr_GaussianProcessRegressor_kernel_, 'tolist') else attr_GaussianProcessRegressor_kernel_`;
    })();
  }
  /**
    Lower-triangular Cholesky decomposition of the kernel in `X\_train\_`.
   */
  get L_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing L_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_L_ = bridgeGaussianProcessRegressor[${this.id}].L_`;
      return this._py`attr_GaussianProcessRegressor_L_.tolist() if hasattr(attr_GaussianProcessRegressor_L_, 'tolist') else attr_GaussianProcessRegressor_L_`;
    })();
  }
  /**
    Dual coefficients of training data points in kernel space.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_alpha_ = bridgeGaussianProcessRegressor[${this.id}].alpha_`;
      return this._py`attr_GaussianProcessRegressor_alpha_.tolist() if hasattr(attr_GaussianProcessRegressor_alpha_, 'tolist') else attr_GaussianProcessRegressor_alpha_`;
    })();
  }
  /**
    The log-marginal-likelihood of `self.kernel\_.theta`.
   */
  get log_marginal_likelihood_value_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing log_marginal_likelihood_value_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_log_marginal_likelihood_value_ = bridgeGaussianProcessRegressor[${this.id}].log_marginal_likelihood_value_`;
      return this._py`attr_GaussianProcessRegressor_log_marginal_likelihood_value_.tolist() if hasattr(attr_GaussianProcessRegressor_log_marginal_likelihood_value_, 'tolist') else attr_GaussianProcessRegressor_log_marginal_likelihood_value_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_n_features_in_ = bridgeGaussianProcessRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GaussianProcessRegressor_n_features_in_.tolist() if hasattr(attr_GaussianProcessRegressor_n_features_in_, 'tolist') else attr_GaussianProcessRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_feature_names_in_ = bridgeGaussianProcessRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianProcessRegressor_feature_names_in_.tolist() if hasattr(attr_GaussianProcessRegressor_feature_names_in_, 'tolist') else attr_GaussianProcessRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/gaussian_process/kernels/CompoundKernel.ts
import crypto3 from "node:crypto";
var CompoundKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CompoundKernel${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CompoundKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import CompoundKernel
try: bridgeCompoundKernel
except NameError: bridgeCompoundKernel = {}
`;
    await this._py.ex`ctor_CompoundKernel = {'kernels': ${this.opts["kernels"] ?? void 0}}

ctor_CompoundKernel = {k: v for k, v in ctor_CompoundKernel.items() if v is not None}`;
    await this._py.ex`bridgeCompoundKernel[${this.id}] = CompoundKernel(**ctor_CompoundKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCompoundKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return the kernel k(X, Y) and optionally its gradient.
  
      Note that this compound kernel returns the results of all simple kernel stacked along an additional axis.
     */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before __call__()");
    }
    await this._py.ex`pms_CompoundKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_CompoundKernel___call__ = {k: v for k, v in pms_CompoundKernel___call__.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel___call__ = bridgeCompoundKernel[${this.id}].__call__(**pms_CompoundKernel___call__)`;
    return this._py`res_CompoundKernel___call__.tolist() if hasattr(res_CompoundKernel___call__, 'tolist') else res_CompoundKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CompoundKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_CompoundKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_CompoundKernel_clone_with_theta = {k: v for k, v in pms_CompoundKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_clone_with_theta = bridgeCompoundKernel[${this.id}].clone_with_theta(**pms_CompoundKernel_clone_with_theta)`;
    return this._py`res_CompoundKernel_clone_with_theta.tolist() if hasattr(res_CompoundKernel_clone_with_theta, 'tolist') else res_CompoundKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to `np.diag(self(X))`; however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before diag()");
    }
    await this._py.ex`pms_CompoundKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CompoundKernel_diag = {k: v for k, v in pms_CompoundKernel_diag.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_diag = bridgeCompoundKernel[${this.id}].diag(**pms_CompoundKernel_diag)`;
    return this._py`res_CompoundKernel_diag.tolist() if hasattr(res_CompoundKernel_diag, 'tolist') else res_CompoundKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_CompoundKernel_is_stationary = {}

pms_CompoundKernel_is_stationary = {k: v for k, v in pms_CompoundKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_is_stationary = bridgeCompoundKernel[${this.id}].is_stationary(**pms_CompoundKernel_is_stationary)`;
    return this._py`res_CompoundKernel_is_stationary.tolist() if hasattr(res_CompoundKernel_is_stationary, 'tolist') else res_CompoundKernel_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/ConstantKernel.ts
import crypto4 from "node:crypto";
var ConstantKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ConstantKernel${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ConstantKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import ConstantKernel
try: bridgeConstantKernel
except NameError: bridgeConstantKernel = {}
`;
    await this._py.ex`ctor_ConstantKernel = {'constant_value': ${this.opts["constant_value"] ?? void 0}, 'constant_value_bounds': ${this.opts["constant_value_bounds"] ?? void 0}}

ctor_ConstantKernel = {k: v for k, v in ctor_ConstantKernel.items() if v is not None}`;
    await this._py.ex`bridgeConstantKernel[${this.id}] = ConstantKernel(**ctor_ConstantKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeConstantKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before __call__()");
    }
    await this._py.ex`pms_ConstantKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_ConstantKernel___call__ = {k: v for k, v in pms_ConstantKernel___call__.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel___call__ = bridgeConstantKernel[${this.id}].__call__(**pms_ConstantKernel___call__)`;
    return this._py`res_ConstantKernel___call__.tolist() if hasattr(res_ConstantKernel___call__, 'tolist') else res_ConstantKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConstantKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_ConstantKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_ConstantKernel_clone_with_theta = {k: v for k, v in pms_ConstantKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_clone_with_theta = bridgeConstantKernel[${this.id}].clone_with_theta(**pms_ConstantKernel_clone_with_theta)`;
    return this._py`res_ConstantKernel_clone_with_theta.tolist() if hasattr(res_ConstantKernel_clone_with_theta, 'tolist') else res_ConstantKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before diag()");
    }
    await this._py.ex`pms_ConstantKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ConstantKernel_diag = {k: v for k, v in pms_ConstantKernel_diag.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_diag = bridgeConstantKernel[${this.id}].diag(**pms_ConstantKernel_diag)`;
    return this._py`res_ConstantKernel_diag.tolist() if hasattr(res_ConstantKernel_diag, 'tolist') else res_ConstantKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_ConstantKernel_is_stationary = {}

pms_ConstantKernel_is_stationary = {k: v for k, v in pms_ConstantKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_is_stationary = bridgeConstantKernel[${this.id}].is_stationary(**pms_ConstantKernel_is_stationary)`;
    return this._py`res_ConstantKernel_is_stationary.tolist() if hasattr(res_ConstantKernel_is_stationary, 'tolist') else res_ConstantKernel_is_stationary`;
  }
  get hyperparameter_constant_value() {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConstantKernel must call init() before accessing hyperparameter_constant_value"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConstantKernel_hyperparameter_constant_value = bridgeConstantKernel[${this.id}].hyperparameter_constant_value`;
      return this._py`attr_ConstantKernel_hyperparameter_constant_value.tolist() if hasattr(attr_ConstantKernel_hyperparameter_constant_value, 'tolist') else attr_ConstantKernel_hyperparameter_constant_value`;
    })();
  }
};

// src/generated/gaussian_process/kernels/DotProduct.ts
import crypto5 from "node:crypto";
var DotProduct = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DotProduct${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DotProduct.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import DotProduct
try: bridgeDotProduct
except NameError: bridgeDotProduct = {}
`;
    await this._py.ex`ctor_DotProduct = {'sigma_0': ${this.opts["sigma_0"] ?? void 0}, 'sigma_0_bounds': ${this.opts["sigma_0_bounds"] ?? void 0}}

ctor_DotProduct = {k: v for k, v in ctor_DotProduct.items() if v is not None}`;
    await this._py.ex`bridgeDotProduct[${this.id}] = DotProduct(**ctor_DotProduct)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDotProduct[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before __call__()");
    }
    await this._py.ex`pms_DotProduct___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_DotProduct___call__ = {k: v for k, v in pms_DotProduct___call__.items() if v is not None}`;
    await this._py.ex`res_DotProduct___call__ = bridgeDotProduct[${this.id}].__call__(**pms_DotProduct___call__)`;
    return this._py`res_DotProduct___call__.tolist() if hasattr(res_DotProduct___call__, 'tolist') else res_DotProduct___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_DotProduct_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_DotProduct_clone_with_theta = {k: v for k, v in pms_DotProduct_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_DotProduct_clone_with_theta = bridgeDotProduct[${this.id}].clone_with_theta(**pms_DotProduct_clone_with_theta)`;
    return this._py`res_DotProduct_clone_with_theta.tolist() if hasattr(res_DotProduct_clone_with_theta, 'tolist') else res_DotProduct_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before diag()");
    }
    await this._py.ex`pms_DotProduct_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DotProduct_diag = {k: v for k, v in pms_DotProduct_diag.items() if v is not None}`;
    await this._py.ex`res_DotProduct_diag = bridgeDotProduct[${this.id}].diag(**pms_DotProduct_diag)`;
    return this._py`res_DotProduct_diag.tolist() if hasattr(res_DotProduct_diag, 'tolist') else res_DotProduct_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before is_stationary()");
    }
    await this._py.ex`pms_DotProduct_is_stationary = {}

pms_DotProduct_is_stationary = {k: v for k, v in pms_DotProduct_is_stationary.items() if v is not None}`;
    await this._py.ex`res_DotProduct_is_stationary = bridgeDotProduct[${this.id}].is_stationary(**pms_DotProduct_is_stationary)`;
    return this._py`res_DotProduct_is_stationary.tolist() if hasattr(res_DotProduct_is_stationary, 'tolist') else res_DotProduct_is_stationary`;
  }
  get hyperparameter_sigma_0() {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DotProduct must call init() before accessing hyperparameter_sigma_0"
      );
    }
    return (async () => {
      await this._py.ex`attr_DotProduct_hyperparameter_sigma_0 = bridgeDotProduct[${this.id}].hyperparameter_sigma_0`;
      return this._py`attr_DotProduct_hyperparameter_sigma_0.tolist() if hasattr(attr_DotProduct_hyperparameter_sigma_0, 'tolist') else attr_DotProduct_hyperparameter_sigma_0`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Exponentiation.ts
import crypto6 from "node:crypto";
var Exponentiation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Exponentiation${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Exponentiation.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Exponentiation
try: bridgeExponentiation
except NameError: bridgeExponentiation = {}
`;
    await this._py.ex`ctor_Exponentiation = {'kernel': ${this.opts["kernel"] ?? void 0}, 'exponent': ${this.opts["exponent"] ?? void 0}}

ctor_Exponentiation = {k: v for k, v in ctor_Exponentiation.items() if v is not None}`;
    await this._py.ex`bridgeExponentiation[${this.id}] = Exponentiation(**ctor_Exponentiation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExponentiation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before __call__()");
    }
    await this._py.ex`pms_Exponentiation___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Exponentiation___call__ = {k: v for k, v in pms_Exponentiation___call__.items() if v is not None}`;
    await this._py.ex`res_Exponentiation___call__ = bridgeExponentiation[${this.id}].__call__(**pms_Exponentiation___call__)`;
    return this._py`res_Exponentiation___call__.tolist() if hasattr(res_Exponentiation___call__, 'tolist') else res_Exponentiation___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Exponentiation must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_Exponentiation_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Exponentiation_clone_with_theta = {k: v for k, v in pms_Exponentiation_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_clone_with_theta = bridgeExponentiation[${this.id}].clone_with_theta(**pms_Exponentiation_clone_with_theta)`;
    return this._py`res_Exponentiation_clone_with_theta.tolist() if hasattr(res_Exponentiation_clone_with_theta, 'tolist') else res_Exponentiation_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before diag()");
    }
    await this._py.ex`pms_Exponentiation_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Exponentiation_diag = {k: v for k, v in pms_Exponentiation_diag.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_diag = bridgeExponentiation[${this.id}].diag(**pms_Exponentiation_diag)`;
    return this._py`res_Exponentiation_diag.tolist() if hasattr(res_Exponentiation_diag, 'tolist') else res_Exponentiation_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before is_stationary()");
    }
    await this._py.ex`pms_Exponentiation_is_stationary = {}

pms_Exponentiation_is_stationary = {k: v for k, v in pms_Exponentiation_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_is_stationary = bridgeExponentiation[${this.id}].is_stationary(**pms_Exponentiation_is_stationary)`;
    return this._py`res_Exponentiation_is_stationary.tolist() if hasattr(res_Exponentiation_is_stationary, 'tolist') else res_Exponentiation_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/ExpSineSquared.ts
import crypto7 from "node:crypto";
var ExpSineSquared = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExpSineSquared${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ExpSineSquared.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import ExpSineSquared
try: bridgeExpSineSquared
except NameError: bridgeExpSineSquared = {}
`;
    await this._py.ex`ctor_ExpSineSquared = {'length_scale': ${this.opts["length_scale"] ?? void 0}, 'periodicity': ${this.opts["periodicity"] ?? void 0}, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'periodicity_bounds': ${this.opts["periodicity_bounds"] ?? void 0}}

ctor_ExpSineSquared = {k: v for k, v in ctor_ExpSineSquared.items() if v is not None}`;
    await this._py.ex`bridgeExpSineSquared[${this.id}] = ExpSineSquared(**ctor_ExpSineSquared)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExpSineSquared[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before __call__()");
    }
    await this._py.ex`pms_ExpSineSquared___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_ExpSineSquared___call__ = {k: v for k, v in pms_ExpSineSquared___call__.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared___call__ = bridgeExpSineSquared[${this.id}].__call__(**pms_ExpSineSquared___call__)`;
    return this._py`res_ExpSineSquared___call__.tolist() if hasattr(res_ExpSineSquared___call__, 'tolist') else res_ExpSineSquared___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExpSineSquared must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_ExpSineSquared_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_ExpSineSquared_clone_with_theta = {k: v for k, v in pms_ExpSineSquared_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_clone_with_theta = bridgeExpSineSquared[${this.id}].clone_with_theta(**pms_ExpSineSquared_clone_with_theta)`;
    return this._py`res_ExpSineSquared_clone_with_theta.tolist() if hasattr(res_ExpSineSquared_clone_with_theta, 'tolist') else res_ExpSineSquared_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before diag()");
    }
    await this._py.ex`pms_ExpSineSquared_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExpSineSquared_diag = {k: v for k, v in pms_ExpSineSquared_diag.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_diag = bridgeExpSineSquared[${this.id}].diag(**pms_ExpSineSquared_diag)`;
    return this._py`res_ExpSineSquared_diag.tolist() if hasattr(res_ExpSineSquared_diag, 'tolist') else res_ExpSineSquared_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before is_stationary()");
    }
    await this._py.ex`pms_ExpSineSquared_is_stationary = {}

pms_ExpSineSquared_is_stationary = {k: v for k, v in pms_ExpSineSquared_is_stationary.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_is_stationary = bridgeExpSineSquared[${this.id}].is_stationary(**pms_ExpSineSquared_is_stationary)`;
    return this._py`res_ExpSineSquared_is_stationary.tolist() if hasattr(res_ExpSineSquared_is_stationary, 'tolist') else res_ExpSineSquared_is_stationary`;
  }
  get hyperparameter_periodicity() {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExpSineSquared must call init() before accessing hyperparameter_periodicity"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExpSineSquared_hyperparameter_periodicity = bridgeExpSineSquared[${this.id}].hyperparameter_periodicity`;
      return this._py`attr_ExpSineSquared_hyperparameter_periodicity.tolist() if hasattr(attr_ExpSineSquared_hyperparameter_periodicity, 'tolist') else attr_ExpSineSquared_hyperparameter_periodicity`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Hyperparameter.ts
import crypto8 from "node:crypto";
var Hyperparameter = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Hyperparameter${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Hyperparameter.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Hyperparameter
try: bridgeHyperparameter
except NameError: bridgeHyperparameter = {}
`;
    await this._py.ex`ctor_Hyperparameter = {'name': ${this.opts["name"] ?? void 0}, 'value_type': ${this.opts["value_type"] ?? void 0}, 'bounds': ${this.opts["bounds"] ?? void 0}, 'n_elements': ${this.opts["n_elements"] ?? void 0}, 'fixed': ${this.opts["fixed"] ?? void 0}}

ctor_Hyperparameter = {k: v for k, v in ctor_Hyperparameter.items() if v is not None}`;
    await this._py.ex`bridgeHyperparameter[${this.id}] = Hyperparameter(**ctor_Hyperparameter)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHyperparameter[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Call self as a function.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before __call__()");
    }
    await this._py.ex`pms_Hyperparameter___call__ = {}

pms_Hyperparameter___call__ = {k: v for k, v in pms_Hyperparameter___call__.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter___call__ = bridgeHyperparameter[${this.id}].__call__(**pms_Hyperparameter___call__)`;
    return this._py`res_Hyperparameter___call__.tolist() if hasattr(res_Hyperparameter___call__, 'tolist') else res_Hyperparameter___call__`;
  }
  /**
    Return number of occurrences of value.
   */
  async count(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before count()");
    }
    await this._py.ex`pms_Hyperparameter_count = {}

pms_Hyperparameter_count = {k: v for k, v in pms_Hyperparameter_count.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter_count = bridgeHyperparameter[${this.id}].count(**pms_Hyperparameter_count)`;
    return this._py`res_Hyperparameter_count.tolist() if hasattr(res_Hyperparameter_count, 'tolist') else res_Hyperparameter_count`;
  }
  /**
      Return first index of value.
  
      Raises ValueError if the value is not present.
     */
  async index(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before index()");
    }
    await this._py.ex`pms_Hyperparameter_index = {}

pms_Hyperparameter_index = {k: v for k, v in pms_Hyperparameter_index.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter_index = bridgeHyperparameter[${this.id}].index(**pms_Hyperparameter_index)`;
    return this._py`res_Hyperparameter_index.tolist() if hasattr(res_Hyperparameter_index, 'tolist') else res_Hyperparameter_index`;
  }
};

// src/generated/gaussian_process/kernels/Kernel.ts
import crypto9 from "node:crypto";
var Kernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Kernel${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Kernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Kernel
try: bridgeKernel
except NameError: bridgeKernel = {}
`;
    await this._py.ex`ctor_Kernel = {}

ctor_Kernel = {k: v for k, v in ctor_Kernel.items() if v is not None}`;
    await this._py.ex`bridgeKernel[${this.id}] = Kernel(**ctor_Kernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the kernel.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before __call__()");
    }
    await this._py.ex`pms_Kernel___call__ = {}

pms_Kernel___call__ = {k: v for k, v in pms_Kernel___call__.items() if v is not None}`;
    await this._py.ex`res_Kernel___call__ = bridgeKernel[${this.id}].__call__(**pms_Kernel___call__)`;
    return this._py`res_Kernel___call__.tolist() if hasattr(res_Kernel___call__, 'tolist') else res_Kernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Kernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Kernel_clone_with_theta = {k: v for k, v in pms_Kernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Kernel_clone_with_theta = bridgeKernel[${this.id}].clone_with_theta(**pms_Kernel_clone_with_theta)`;
    return this._py`res_Kernel_clone_with_theta.tolist() if hasattr(res_Kernel_clone_with_theta, 'tolist') else res_Kernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before diag()");
    }
    await this._py.ex`pms_Kernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Kernel_diag = {k: v for k, v in pms_Kernel_diag.items() if v is not None}`;
    await this._py.ex`res_Kernel_diag = bridgeKernel[${this.id}].diag(**pms_Kernel_diag)`;
    return this._py`res_Kernel_diag.tolist() if hasattr(res_Kernel_diag, 'tolist') else res_Kernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_Kernel_is_stationary = {}

pms_Kernel_is_stationary = {k: v for k, v in pms_Kernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Kernel_is_stationary = bridgeKernel[${this.id}].is_stationary(**pms_Kernel_is_stationary)`;
    return this._py`res_Kernel_is_stationary.tolist() if hasattr(res_Kernel_is_stationary, 'tolist') else res_Kernel_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/Matern.ts
import crypto10 from "node:crypto";
var Matern = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Matern${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Matern.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Matern
try: bridgeMatern
except NameError: bridgeMatern = {}
`;
    await this._py.ex`ctor_Matern = {'length_scale': np.array(${this.opts["length_scale"] ?? void 0}) if ${this.opts["length_scale"] !== void 0} else None, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'nu': ${this.opts["nu"] ?? void 0}}

ctor_Matern = {k: v for k, v in ctor_Matern.items() if v is not None}`;
    await this._py.ex`bridgeMatern[${this.id}] = Matern(**ctor_Matern)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMatern[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before __call__()");
    }
    await this._py.ex`pms_Matern___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Matern___call__ = {k: v for k, v in pms_Matern___call__.items() if v is not None}`;
    await this._py.ex`res_Matern___call__ = bridgeMatern[${this.id}].__call__(**pms_Matern___call__)`;
    return this._py`res_Matern___call__.tolist() if hasattr(res_Matern___call__, 'tolist') else res_Matern___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Matern_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Matern_clone_with_theta = {k: v for k, v in pms_Matern_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Matern_clone_with_theta = bridgeMatern[${this.id}].clone_with_theta(**pms_Matern_clone_with_theta)`;
    return this._py`res_Matern_clone_with_theta.tolist() if hasattr(res_Matern_clone_with_theta, 'tolist') else res_Matern_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before diag()");
    }
    await this._py.ex`pms_Matern_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Matern_diag = {k: v for k, v in pms_Matern_diag.items() if v is not None}`;
    await this._py.ex`res_Matern_diag = bridgeMatern[${this.id}].diag(**pms_Matern_diag)`;
    return this._py`res_Matern_diag.tolist() if hasattr(res_Matern_diag, 'tolist') else res_Matern_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before is_stationary()");
    }
    await this._py.ex`pms_Matern_is_stationary = {}

pms_Matern_is_stationary = {k: v for k, v in pms_Matern_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Matern_is_stationary = bridgeMatern[${this.id}].is_stationary(**pms_Matern_is_stationary)`;
    return this._py`res_Matern_is_stationary.tolist() if hasattr(res_Matern_is_stationary, 'tolist') else res_Matern_is_stationary`;
  }
  get anisotropic() {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before accessing anisotropic");
    }
    return (async () => {
      await this._py.ex`attr_Matern_anisotropic = bridgeMatern[${this.id}].anisotropic`;
      return this._py`attr_Matern_anisotropic.tolist() if hasattr(attr_Matern_anisotropic, 'tolist') else attr_Matern_anisotropic`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Matern must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_Matern_hyperparameter_length_scale = bridgeMatern[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_Matern_hyperparameter_length_scale.tolist() if hasattr(attr_Matern_hyperparameter_length_scale, 'tolist') else attr_Matern_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/PairwiseKernel.ts
import crypto11 from "node:crypto";
var PairwiseKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PairwiseKernel${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PairwiseKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import PairwiseKernel
try: bridgePairwiseKernel
except NameError: bridgePairwiseKernel = {}
`;
    await this._py.ex`ctor_PairwiseKernel = {'gamma': ${this.opts["gamma"] ?? void 0}, 'gamma_bounds': ${this.opts["gamma_bounds"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'pairwise_kernels_kwargs': ${this.opts["pairwise_kernels_kwargs"] ?? void 0}}

ctor_PairwiseKernel = {k: v for k, v in ctor_PairwiseKernel.items() if v is not None}`;
    await this._py.ex`bridgePairwiseKernel[${this.id}] = PairwiseKernel(**ctor_PairwiseKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePairwiseKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before __call__()");
    }
    await this._py.ex`pms_PairwiseKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_PairwiseKernel___call__ = {k: v for k, v in pms_PairwiseKernel___call__.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel___call__ = bridgePairwiseKernel[${this.id}].__call__(**pms_PairwiseKernel___call__)`;
    return this._py`res_PairwiseKernel___call__.tolist() if hasattr(res_PairwiseKernel___call__, 'tolist') else res_PairwiseKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PairwiseKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_PairwiseKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_PairwiseKernel_clone_with_theta = {k: v for k, v in pms_PairwiseKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_clone_with_theta = bridgePairwiseKernel[${this.id}].clone_with_theta(**pms_PairwiseKernel_clone_with_theta)`;
    return this._py`res_PairwiseKernel_clone_with_theta.tolist() if hasattr(res_PairwiseKernel_clone_with_theta, 'tolist') else res_PairwiseKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before diag()");
    }
    await this._py.ex`pms_PairwiseKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PairwiseKernel_diag = {k: v for k, v in pms_PairwiseKernel_diag.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_diag = bridgePairwiseKernel[${this.id}].diag(**pms_PairwiseKernel_diag)`;
    return this._py`res_PairwiseKernel_diag.tolist() if hasattr(res_PairwiseKernel_diag, 'tolist') else res_PairwiseKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_PairwiseKernel_is_stationary = {}

pms_PairwiseKernel_is_stationary = {k: v for k, v in pms_PairwiseKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_is_stationary = bridgePairwiseKernel[${this.id}].is_stationary(**pms_PairwiseKernel_is_stationary)`;
    return this._py`res_PairwiseKernel_is_stationary.tolist() if hasattr(res_PairwiseKernel_is_stationary, 'tolist') else res_PairwiseKernel_is_stationary`;
  }
  get hyperparameter_gamma() {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PairwiseKernel must call init() before accessing hyperparameter_gamma"
      );
    }
    return (async () => {
      await this._py.ex`attr_PairwiseKernel_hyperparameter_gamma = bridgePairwiseKernel[${this.id}].hyperparameter_gamma`;
      return this._py`attr_PairwiseKernel_hyperparameter_gamma.tolist() if hasattr(attr_PairwiseKernel_hyperparameter_gamma, 'tolist') else attr_PairwiseKernel_hyperparameter_gamma`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Product.ts
import crypto12 from "node:crypto";
var Product = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Product${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Product.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Product
try: bridgeProduct
except NameError: bridgeProduct = {}
`;
    await this._py.ex`ctor_Product = {'k1': ${this.opts["k1"] ?? void 0}, 'k2': ${this.opts["k2"] ?? void 0}}

ctor_Product = {k: v for k, v in ctor_Product.items() if v is not None}`;
    await this._py.ex`bridgeProduct[${this.id}] = Product(**ctor_Product)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeProduct[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before __call__()");
    }
    await this._py.ex`pms_Product___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Product___call__ = {k: v for k, v in pms_Product___call__.items() if v is not None}`;
    await this._py.ex`res_Product___call__ = bridgeProduct[${this.id}].__call__(**pms_Product___call__)`;
    return this._py`res_Product___call__.tolist() if hasattr(res_Product___call__, 'tolist') else res_Product___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Product_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Product_clone_with_theta = {k: v for k, v in pms_Product_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Product_clone_with_theta = bridgeProduct[${this.id}].clone_with_theta(**pms_Product_clone_with_theta)`;
    return this._py`res_Product_clone_with_theta.tolist() if hasattr(res_Product_clone_with_theta, 'tolist') else res_Product_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before diag()");
    }
    await this._py.ex`pms_Product_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Product_diag = {k: v for k, v in pms_Product_diag.items() if v is not None}`;
    await this._py.ex`res_Product_diag = bridgeProduct[${this.id}].diag(**pms_Product_diag)`;
    return this._py`res_Product_diag.tolist() if hasattr(res_Product_diag, 'tolist') else res_Product_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before is_stationary()");
    }
    await this._py.ex`pms_Product_is_stationary = {}

pms_Product_is_stationary = {k: v for k, v in pms_Product_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Product_is_stationary = bridgeProduct[${this.id}].is_stationary(**pms_Product_is_stationary)`;
    return this._py`res_Product_is_stationary.tolist() if hasattr(res_Product_is_stationary, 'tolist') else res_Product_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/RationalQuadratic.ts
import crypto13 from "node:crypto";
var RationalQuadratic = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RationalQuadratic${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RationalQuadratic.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import RationalQuadratic
try: bridgeRationalQuadratic
except NameError: bridgeRationalQuadratic = {}
`;
    await this._py.ex`ctor_RationalQuadratic = {'length_scale': ${this.opts["length_scale"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'alpha_bounds': ${this.opts["alpha_bounds"] ?? void 0}}

ctor_RationalQuadratic = {k: v for k, v in ctor_RationalQuadratic.items() if v is not None}`;
    await this._py.ex`bridgeRationalQuadratic[${this.id}] = RationalQuadratic(**ctor_RationalQuadratic)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRationalQuadratic[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RationalQuadratic must call init() before __call__()");
    }
    await this._py.ex`pms_RationalQuadratic___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_RationalQuadratic___call__ = {k: v for k, v in pms_RationalQuadratic___call__.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic___call__ = bridgeRationalQuadratic[${this.id}].__call__(**pms_RationalQuadratic___call__)`;
    return this._py`res_RationalQuadratic___call__.tolist() if hasattr(res_RationalQuadratic___call__, 'tolist') else res_RationalQuadratic___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_RationalQuadratic_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_RationalQuadratic_clone_with_theta = {k: v for k, v in pms_RationalQuadratic_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_clone_with_theta = bridgeRationalQuadratic[${this.id}].clone_with_theta(**pms_RationalQuadratic_clone_with_theta)`;
    return this._py`res_RationalQuadratic_clone_with_theta.tolist() if hasattr(res_RationalQuadratic_clone_with_theta, 'tolist') else res_RationalQuadratic_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RationalQuadratic must call init() before diag()");
    }
    await this._py.ex`pms_RationalQuadratic_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RationalQuadratic_diag = {k: v for k, v in pms_RationalQuadratic_diag.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_diag = bridgeRationalQuadratic[${this.id}].diag(**pms_RationalQuadratic_diag)`;
    return this._py`res_RationalQuadratic_diag.tolist() if hasattr(res_RationalQuadratic_diag, 'tolist') else res_RationalQuadratic_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before is_stationary()"
      );
    }
    await this._py.ex`pms_RationalQuadratic_is_stationary = {}

pms_RationalQuadratic_is_stationary = {k: v for k, v in pms_RationalQuadratic_is_stationary.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_is_stationary = bridgeRationalQuadratic[${this.id}].is_stationary(**pms_RationalQuadratic_is_stationary)`;
    return this._py`res_RationalQuadratic_is_stationary.tolist() if hasattr(res_RationalQuadratic_is_stationary, 'tolist') else res_RationalQuadratic_is_stationary`;
  }
  get hyperparameter_alpha() {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before accessing hyperparameter_alpha"
      );
    }
    return (async () => {
      await this._py.ex`attr_RationalQuadratic_hyperparameter_alpha = bridgeRationalQuadratic[${this.id}].hyperparameter_alpha`;
      return this._py`attr_RationalQuadratic_hyperparameter_alpha.tolist() if hasattr(attr_RationalQuadratic_hyperparameter_alpha, 'tolist') else attr_RationalQuadratic_hyperparameter_alpha`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_RationalQuadratic_hyperparameter_length_scale = bridgeRationalQuadratic[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_RationalQuadratic_hyperparameter_length_scale.tolist() if hasattr(attr_RationalQuadratic_hyperparameter_length_scale, 'tolist') else attr_RationalQuadratic_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/RBF.ts
import crypto14 from "node:crypto";
var RBF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RBF${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RBF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import RBF
try: bridgeRBF
except NameError: bridgeRBF = {}
`;
    await this._py.ex`ctor_RBF = {'length_scale': np.array(${this.opts["length_scale"] ?? void 0}) if ${this.opts["length_scale"] !== void 0} else None, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}}

ctor_RBF = {k: v for k, v in ctor_RBF.items() if v is not None}`;
    await this._py.ex`bridgeRBF[${this.id}] = RBF(**ctor_RBF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRBF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before __call__()");
    }
    await this._py.ex`pms_RBF___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_RBF___call__ = {k: v for k, v in pms_RBF___call__.items() if v is not None}`;
    await this._py.ex`res_RBF___call__ = bridgeRBF[${this.id}].__call__(**pms_RBF___call__)`;
    return this._py`res_RBF___call__.tolist() if hasattr(res_RBF___call__, 'tolist') else res_RBF___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_RBF_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_RBF_clone_with_theta = {k: v for k, v in pms_RBF_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_RBF_clone_with_theta = bridgeRBF[${this.id}].clone_with_theta(**pms_RBF_clone_with_theta)`;
    return this._py`res_RBF_clone_with_theta.tolist() if hasattr(res_RBF_clone_with_theta, 'tolist') else res_RBF_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before diag()");
    }
    await this._py.ex`pms_RBF_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RBF_diag = {k: v for k, v in pms_RBF_diag.items() if v is not None}`;
    await this._py.ex`res_RBF_diag = bridgeRBF[${this.id}].diag(**pms_RBF_diag)`;
    return this._py`res_RBF_diag.tolist() if hasattr(res_RBF_diag, 'tolist') else res_RBF_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before is_stationary()");
    }
    await this._py.ex`pms_RBF_is_stationary = {}

pms_RBF_is_stationary = {k: v for k, v in pms_RBF_is_stationary.items() if v is not None}`;
    await this._py.ex`res_RBF_is_stationary = bridgeRBF[${this.id}].is_stationary(**pms_RBF_is_stationary)`;
    return this._py`res_RBF_is_stationary.tolist() if hasattr(res_RBF_is_stationary, 'tolist') else res_RBF_is_stationary`;
  }
  get anisotropic() {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before accessing anisotropic");
    }
    return (async () => {
      await this._py.ex`attr_RBF_anisotropic = bridgeRBF[${this.id}].anisotropic`;
      return this._py`attr_RBF_anisotropic.tolist() if hasattr(attr_RBF_anisotropic, 'tolist') else attr_RBF_anisotropic`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBF must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBF_hyperparameter_length_scale = bridgeRBF[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_RBF_hyperparameter_length_scale.tolist() if hasattr(attr_RBF_hyperparameter_length_scale, 'tolist') else attr_RBF_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Sum.ts
import crypto15 from "node:crypto";
var Sum = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Sum${crypto15.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Sum.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Sum
try: bridgeSum
except NameError: bridgeSum = {}
`;
    await this._py.ex`ctor_Sum = {'k1': ${this.opts["k1"] ?? void 0}, 'k2': ${this.opts["k2"] ?? void 0}}

ctor_Sum = {k: v for k, v in ctor_Sum.items() if v is not None}`;
    await this._py.ex`bridgeSum[${this.id}] = Sum(**ctor_Sum)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSum[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before __call__()");
    }
    await this._py.ex`pms_Sum___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Sum___call__ = {k: v for k, v in pms_Sum___call__.items() if v is not None}`;
    await this._py.ex`res_Sum___call__ = bridgeSum[${this.id}].__call__(**pms_Sum___call__)`;
    return this._py`res_Sum___call__.tolist() if hasattr(res_Sum___call__, 'tolist') else res_Sum___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Sum_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Sum_clone_with_theta = {k: v for k, v in pms_Sum_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Sum_clone_with_theta = bridgeSum[${this.id}].clone_with_theta(**pms_Sum_clone_with_theta)`;
    return this._py`res_Sum_clone_with_theta.tolist() if hasattr(res_Sum_clone_with_theta, 'tolist') else res_Sum_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to `np.diag(self(X))`; however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before diag()");
    }
    await this._py.ex`pms_Sum_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Sum_diag = {k: v for k, v in pms_Sum_diag.items() if v is not None}`;
    await this._py.ex`res_Sum_diag = bridgeSum[${this.id}].diag(**pms_Sum_diag)`;
    return this._py`res_Sum_diag.tolist() if hasattr(res_Sum_diag, 'tolist') else res_Sum_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before is_stationary()");
    }
    await this._py.ex`pms_Sum_is_stationary = {}

pms_Sum_is_stationary = {k: v for k, v in pms_Sum_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Sum_is_stationary = bridgeSum[${this.id}].is_stationary(**pms_Sum_is_stationary)`;
    return this._py`res_Sum_is_stationary.tolist() if hasattr(res_Sum_is_stationary, 'tolist') else res_Sum_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/WhiteKernel.ts
import crypto16 from "node:crypto";
var WhiteKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `WhiteKernel${crypto16.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("WhiteKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import WhiteKernel
try: bridgeWhiteKernel
except NameError: bridgeWhiteKernel = {}
`;
    await this._py.ex`ctor_WhiteKernel = {'noise_level': ${this.opts["noise_level"] ?? void 0}, 'noise_level_bounds': ${this.opts["noise_level_bounds"] ?? void 0}}

ctor_WhiteKernel = {k: v for k, v in ctor_WhiteKernel.items() if v is not None}`;
    await this._py.ex`bridgeWhiteKernel[${this.id}] = WhiteKernel(**ctor_WhiteKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeWhiteKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before __call__()");
    }
    await this._py.ex`pms_WhiteKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_WhiteKernel___call__ = {k: v for k, v in pms_WhiteKernel___call__.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel___call__ = bridgeWhiteKernel[${this.id}].__call__(**pms_WhiteKernel___call__)`;
    return this._py`res_WhiteKernel___call__.tolist() if hasattr(res_WhiteKernel___call__, 'tolist') else res_WhiteKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_WhiteKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_WhiteKernel_clone_with_theta = {k: v for k, v in pms_WhiteKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_clone_with_theta = bridgeWhiteKernel[${this.id}].clone_with_theta(**pms_WhiteKernel_clone_with_theta)`;
    return this._py`res_WhiteKernel_clone_with_theta.tolist() if hasattr(res_WhiteKernel_clone_with_theta, 'tolist') else res_WhiteKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before diag()");
    }
    await this._py.ex`pms_WhiteKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_WhiteKernel_diag = {k: v for k, v in pms_WhiteKernel_diag.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_diag = bridgeWhiteKernel[${this.id}].diag(**pms_WhiteKernel_diag)`;
    return this._py`res_WhiteKernel_diag.tolist() if hasattr(res_WhiteKernel_diag, 'tolist') else res_WhiteKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_WhiteKernel_is_stationary = {}

pms_WhiteKernel_is_stationary = {k: v for k, v in pms_WhiteKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_is_stationary = bridgeWhiteKernel[${this.id}].is_stationary(**pms_WhiteKernel_is_stationary)`;
    return this._py`res_WhiteKernel_is_stationary.tolist() if hasattr(res_WhiteKernel_is_stationary, 'tolist') else res_WhiteKernel_is_stationary`;
  }
  get hyperparameter_noise_level() {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "WhiteKernel must call init() before accessing hyperparameter_noise_level"
      );
    }
    return (async () => {
      await this._py.ex`attr_WhiteKernel_hyperparameter_noise_level = bridgeWhiteKernel[${this.id}].hyperparameter_noise_level`;
      return this._py`attr_WhiteKernel_hyperparameter_noise_level.tolist() if hasattr(attr_WhiteKernel_hyperparameter_noise_level, 'tolist') else attr_WhiteKernel_hyperparameter_noise_level`;
    })();
  }
};
export {
  CompoundKernel,
  ConstantKernel,
  DotProduct,
  ExpSineSquared,
  Exponentiation,
  GaussianProcessClassifier,
  GaussianProcessRegressor,
  Hyperparameter,
  Kernel,
  Matern,
  PairwiseKernel,
  Product,
  RBF,
  RationalQuadratic,
  Sum,
  WhiteKernel
};
//# sourceMappingURL=index.js.map