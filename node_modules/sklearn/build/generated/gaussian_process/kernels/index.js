// src/generated/gaussian_process/kernels/CompoundKernel.ts
import crypto from "node:crypto";
var CompoundKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `CompoundKernel${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CompoundKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import CompoundKernel
try: bridgeCompoundKernel
except NameError: bridgeCompoundKernel = {}
`;
    await this._py.ex`ctor_CompoundKernel = {'kernels': ${this.opts["kernels"] ?? void 0}}

ctor_CompoundKernel = {k: v for k, v in ctor_CompoundKernel.items() if v is not None}`;
    await this._py.ex`bridgeCompoundKernel[${this.id}] = CompoundKernel(**ctor_CompoundKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCompoundKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return the kernel k(X, Y) and optionally its gradient.
  
      Note that this compound kernel returns the results of all simple kernel stacked along an additional axis.
     */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before __call__()");
    }
    await this._py.ex`pms_CompoundKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_CompoundKernel___call__ = {k: v for k, v in pms_CompoundKernel___call__.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel___call__ = bridgeCompoundKernel[${this.id}].__call__(**pms_CompoundKernel___call__)`;
    return this._py`res_CompoundKernel___call__.tolist() if hasattr(res_CompoundKernel___call__, 'tolist') else res_CompoundKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "CompoundKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_CompoundKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_CompoundKernel_clone_with_theta = {k: v for k, v in pms_CompoundKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_clone_with_theta = bridgeCompoundKernel[${this.id}].clone_with_theta(**pms_CompoundKernel_clone_with_theta)`;
    return this._py`res_CompoundKernel_clone_with_theta.tolist() if hasattr(res_CompoundKernel_clone_with_theta, 'tolist') else res_CompoundKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to `np.diag(self(X))`; however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before diag()");
    }
    await this._py.ex`pms_CompoundKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CompoundKernel_diag = {k: v for k, v in pms_CompoundKernel_diag.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_diag = bridgeCompoundKernel[${this.id}].diag(**pms_CompoundKernel_diag)`;
    return this._py`res_CompoundKernel_diag.tolist() if hasattr(res_CompoundKernel_diag, 'tolist') else res_CompoundKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This CompoundKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CompoundKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_CompoundKernel_is_stationary = {}

pms_CompoundKernel_is_stationary = {k: v for k, v in pms_CompoundKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_CompoundKernel_is_stationary = bridgeCompoundKernel[${this.id}].is_stationary(**pms_CompoundKernel_is_stationary)`;
    return this._py`res_CompoundKernel_is_stationary.tolist() if hasattr(res_CompoundKernel_is_stationary, 'tolist') else res_CompoundKernel_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/ConstantKernel.ts
import crypto2 from "node:crypto";
var ConstantKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ConstantKernel${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ConstantKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import ConstantKernel
try: bridgeConstantKernel
except NameError: bridgeConstantKernel = {}
`;
    await this._py.ex`ctor_ConstantKernel = {'constant_value': ${this.opts["constant_value"] ?? void 0}, 'constant_value_bounds': ${this.opts["constant_value_bounds"] ?? void 0}}

ctor_ConstantKernel = {k: v for k, v in ctor_ConstantKernel.items() if v is not None}`;
    await this._py.ex`bridgeConstantKernel[${this.id}] = ConstantKernel(**ctor_ConstantKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeConstantKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before __call__()");
    }
    await this._py.ex`pms_ConstantKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_ConstantKernel___call__ = {k: v for k, v in pms_ConstantKernel___call__.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel___call__ = bridgeConstantKernel[${this.id}].__call__(**pms_ConstantKernel___call__)`;
    return this._py`res_ConstantKernel___call__.tolist() if hasattr(res_ConstantKernel___call__, 'tolist') else res_ConstantKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConstantKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_ConstantKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_ConstantKernel_clone_with_theta = {k: v for k, v in pms_ConstantKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_clone_with_theta = bridgeConstantKernel[${this.id}].clone_with_theta(**pms_ConstantKernel_clone_with_theta)`;
    return this._py`res_ConstantKernel_clone_with_theta.tolist() if hasattr(res_ConstantKernel_clone_with_theta, 'tolist') else res_ConstantKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before diag()");
    }
    await this._py.ex`pms_ConstantKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ConstantKernel_diag = {k: v for k, v in pms_ConstantKernel_diag.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_diag = bridgeConstantKernel[${this.id}].diag(**pms_ConstantKernel_diag)`;
    return this._py`res_ConstantKernel_diag.tolist() if hasattr(res_ConstantKernel_diag, 'tolist') else res_ConstantKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ConstantKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_ConstantKernel_is_stationary = {}

pms_ConstantKernel_is_stationary = {k: v for k, v in pms_ConstantKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_ConstantKernel_is_stationary = bridgeConstantKernel[${this.id}].is_stationary(**pms_ConstantKernel_is_stationary)`;
    return this._py`res_ConstantKernel_is_stationary.tolist() if hasattr(res_ConstantKernel_is_stationary, 'tolist') else res_ConstantKernel_is_stationary`;
  }
  get hyperparameter_constant_value() {
    if (this._isDisposed) {
      throw new Error("This ConstantKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ConstantKernel must call init() before accessing hyperparameter_constant_value"
      );
    }
    return (async () => {
      await this._py.ex`attr_ConstantKernel_hyperparameter_constant_value = bridgeConstantKernel[${this.id}].hyperparameter_constant_value`;
      return this._py`attr_ConstantKernel_hyperparameter_constant_value.tolist() if hasattr(attr_ConstantKernel_hyperparameter_constant_value, 'tolist') else attr_ConstantKernel_hyperparameter_constant_value`;
    })();
  }
};

// src/generated/gaussian_process/kernels/DotProduct.ts
import crypto3 from "node:crypto";
var DotProduct = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `DotProduct${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DotProduct.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import DotProduct
try: bridgeDotProduct
except NameError: bridgeDotProduct = {}
`;
    await this._py.ex`ctor_DotProduct = {'sigma_0': ${this.opts["sigma_0"] ?? void 0}, 'sigma_0_bounds': ${this.opts["sigma_0_bounds"] ?? void 0}}

ctor_DotProduct = {k: v for k, v in ctor_DotProduct.items() if v is not None}`;
    await this._py.ex`bridgeDotProduct[${this.id}] = DotProduct(**ctor_DotProduct)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDotProduct[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before __call__()");
    }
    await this._py.ex`pms_DotProduct___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_DotProduct___call__ = {k: v for k, v in pms_DotProduct___call__.items() if v is not None}`;
    await this._py.ex`res_DotProduct___call__ = bridgeDotProduct[${this.id}].__call__(**pms_DotProduct___call__)`;
    return this._py`res_DotProduct___call__.tolist() if hasattr(res_DotProduct___call__, 'tolist') else res_DotProduct___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_DotProduct_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_DotProduct_clone_with_theta = {k: v for k, v in pms_DotProduct_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_DotProduct_clone_with_theta = bridgeDotProduct[${this.id}].clone_with_theta(**pms_DotProduct_clone_with_theta)`;
    return this._py`res_DotProduct_clone_with_theta.tolist() if hasattr(res_DotProduct_clone_with_theta, 'tolist') else res_DotProduct_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before diag()");
    }
    await this._py.ex`pms_DotProduct_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DotProduct_diag = {k: v for k, v in pms_DotProduct_diag.items() if v is not None}`;
    await this._py.ex`res_DotProduct_diag = bridgeDotProduct[${this.id}].diag(**pms_DotProduct_diag)`;
    return this._py`res_DotProduct_diag.tolist() if hasattr(res_DotProduct_diag, 'tolist') else res_DotProduct_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DotProduct must call init() before is_stationary()");
    }
    await this._py.ex`pms_DotProduct_is_stationary = {}

pms_DotProduct_is_stationary = {k: v for k, v in pms_DotProduct_is_stationary.items() if v is not None}`;
    await this._py.ex`res_DotProduct_is_stationary = bridgeDotProduct[${this.id}].is_stationary(**pms_DotProduct_is_stationary)`;
    return this._py`res_DotProduct_is_stationary.tolist() if hasattr(res_DotProduct_is_stationary, 'tolist') else res_DotProduct_is_stationary`;
  }
  get hyperparameter_sigma_0() {
    if (this._isDisposed) {
      throw new Error("This DotProduct instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DotProduct must call init() before accessing hyperparameter_sigma_0"
      );
    }
    return (async () => {
      await this._py.ex`attr_DotProduct_hyperparameter_sigma_0 = bridgeDotProduct[${this.id}].hyperparameter_sigma_0`;
      return this._py`attr_DotProduct_hyperparameter_sigma_0.tolist() if hasattr(attr_DotProduct_hyperparameter_sigma_0, 'tolist') else attr_DotProduct_hyperparameter_sigma_0`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Exponentiation.ts
import crypto4 from "node:crypto";
var Exponentiation = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Exponentiation${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Exponentiation.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Exponentiation
try: bridgeExponentiation
except NameError: bridgeExponentiation = {}
`;
    await this._py.ex`ctor_Exponentiation = {'kernel': ${this.opts["kernel"] ?? void 0}, 'exponent': ${this.opts["exponent"] ?? void 0}}

ctor_Exponentiation = {k: v for k, v in ctor_Exponentiation.items() if v is not None}`;
    await this._py.ex`bridgeExponentiation[${this.id}] = Exponentiation(**ctor_Exponentiation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExponentiation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before __call__()");
    }
    await this._py.ex`pms_Exponentiation___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Exponentiation___call__ = {k: v for k, v in pms_Exponentiation___call__.items() if v is not None}`;
    await this._py.ex`res_Exponentiation___call__ = bridgeExponentiation[${this.id}].__call__(**pms_Exponentiation___call__)`;
    return this._py`res_Exponentiation___call__.tolist() if hasattr(res_Exponentiation___call__, 'tolist') else res_Exponentiation___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Exponentiation must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_Exponentiation_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Exponentiation_clone_with_theta = {k: v for k, v in pms_Exponentiation_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_clone_with_theta = bridgeExponentiation[${this.id}].clone_with_theta(**pms_Exponentiation_clone_with_theta)`;
    return this._py`res_Exponentiation_clone_with_theta.tolist() if hasattr(res_Exponentiation_clone_with_theta, 'tolist') else res_Exponentiation_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before diag()");
    }
    await this._py.ex`pms_Exponentiation_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Exponentiation_diag = {k: v for k, v in pms_Exponentiation_diag.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_diag = bridgeExponentiation[${this.id}].diag(**pms_Exponentiation_diag)`;
    return this._py`res_Exponentiation_diag.tolist() if hasattr(res_Exponentiation_diag, 'tolist') else res_Exponentiation_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Exponentiation instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Exponentiation must call init() before is_stationary()");
    }
    await this._py.ex`pms_Exponentiation_is_stationary = {}

pms_Exponentiation_is_stationary = {k: v for k, v in pms_Exponentiation_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Exponentiation_is_stationary = bridgeExponentiation[${this.id}].is_stationary(**pms_Exponentiation_is_stationary)`;
    return this._py`res_Exponentiation_is_stationary.tolist() if hasattr(res_Exponentiation_is_stationary, 'tolist') else res_Exponentiation_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/ExpSineSquared.ts
import crypto5 from "node:crypto";
var ExpSineSquared = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `ExpSineSquared${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ExpSineSquared.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import ExpSineSquared
try: bridgeExpSineSquared
except NameError: bridgeExpSineSquared = {}
`;
    await this._py.ex`ctor_ExpSineSquared = {'length_scale': ${this.opts["length_scale"] ?? void 0}, 'periodicity': ${this.opts["periodicity"] ?? void 0}, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'periodicity_bounds': ${this.opts["periodicity_bounds"] ?? void 0}}

ctor_ExpSineSquared = {k: v for k, v in ctor_ExpSineSquared.items() if v is not None}`;
    await this._py.ex`bridgeExpSineSquared[${this.id}] = ExpSineSquared(**ctor_ExpSineSquared)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExpSineSquared[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before __call__()");
    }
    await this._py.ex`pms_ExpSineSquared___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_ExpSineSquared___call__ = {k: v for k, v in pms_ExpSineSquared___call__.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared___call__ = bridgeExpSineSquared[${this.id}].__call__(**pms_ExpSineSquared___call__)`;
    return this._py`res_ExpSineSquared___call__.tolist() if hasattr(res_ExpSineSquared___call__, 'tolist') else res_ExpSineSquared___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExpSineSquared must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_ExpSineSquared_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_ExpSineSquared_clone_with_theta = {k: v for k, v in pms_ExpSineSquared_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_clone_with_theta = bridgeExpSineSquared[${this.id}].clone_with_theta(**pms_ExpSineSquared_clone_with_theta)`;
    return this._py`res_ExpSineSquared_clone_with_theta.tolist() if hasattr(res_ExpSineSquared_clone_with_theta, 'tolist') else res_ExpSineSquared_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before diag()");
    }
    await this._py.ex`pms_ExpSineSquared_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExpSineSquared_diag = {k: v for k, v in pms_ExpSineSquared_diag.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_diag = bridgeExpSineSquared[${this.id}].diag(**pms_ExpSineSquared_diag)`;
    return this._py`res_ExpSineSquared_diag.tolist() if hasattr(res_ExpSineSquared_diag, 'tolist') else res_ExpSineSquared_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("ExpSineSquared must call init() before is_stationary()");
    }
    await this._py.ex`pms_ExpSineSquared_is_stationary = {}

pms_ExpSineSquared_is_stationary = {k: v for k, v in pms_ExpSineSquared_is_stationary.items() if v is not None}`;
    await this._py.ex`res_ExpSineSquared_is_stationary = bridgeExpSineSquared[${this.id}].is_stationary(**pms_ExpSineSquared_is_stationary)`;
    return this._py`res_ExpSineSquared_is_stationary.tolist() if hasattr(res_ExpSineSquared_is_stationary, 'tolist') else res_ExpSineSquared_is_stationary`;
  }
  get hyperparameter_periodicity() {
    if (this._isDisposed) {
      throw new Error("This ExpSineSquared instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExpSineSquared must call init() before accessing hyperparameter_periodicity"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExpSineSquared_hyperparameter_periodicity = bridgeExpSineSquared[${this.id}].hyperparameter_periodicity`;
      return this._py`attr_ExpSineSquared_hyperparameter_periodicity.tolist() if hasattr(attr_ExpSineSquared_hyperparameter_periodicity, 'tolist') else attr_ExpSineSquared_hyperparameter_periodicity`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Hyperparameter.ts
import crypto6 from "node:crypto";
var Hyperparameter = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Hyperparameter${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Hyperparameter.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Hyperparameter
try: bridgeHyperparameter
except NameError: bridgeHyperparameter = {}
`;
    await this._py.ex`ctor_Hyperparameter = {'name': ${this.opts["name"] ?? void 0}, 'value_type': ${this.opts["value_type"] ?? void 0}, 'bounds': ${this.opts["bounds"] ?? void 0}, 'n_elements': ${this.opts["n_elements"] ?? void 0}, 'fixed': ${this.opts["fixed"] ?? void 0}}

ctor_Hyperparameter = {k: v for k, v in ctor_Hyperparameter.items() if v is not None}`;
    await this._py.ex`bridgeHyperparameter[${this.id}] = Hyperparameter(**ctor_Hyperparameter)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHyperparameter[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Call self as a function.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before __call__()");
    }
    await this._py.ex`pms_Hyperparameter___call__ = {}

pms_Hyperparameter___call__ = {k: v for k, v in pms_Hyperparameter___call__.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter___call__ = bridgeHyperparameter[${this.id}].__call__(**pms_Hyperparameter___call__)`;
    return this._py`res_Hyperparameter___call__.tolist() if hasattr(res_Hyperparameter___call__, 'tolist') else res_Hyperparameter___call__`;
  }
  /**
    Return number of occurrences of value.
   */
  async count(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before count()");
    }
    await this._py.ex`pms_Hyperparameter_count = {}

pms_Hyperparameter_count = {k: v for k, v in pms_Hyperparameter_count.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter_count = bridgeHyperparameter[${this.id}].count(**pms_Hyperparameter_count)`;
    return this._py`res_Hyperparameter_count.tolist() if hasattr(res_Hyperparameter_count, 'tolist') else res_Hyperparameter_count`;
  }
  /**
      Return first index of value.
  
      Raises ValueError if the value is not present.
     */
  async index(opts) {
    if (this._isDisposed) {
      throw new Error("This Hyperparameter instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Hyperparameter must call init() before index()");
    }
    await this._py.ex`pms_Hyperparameter_index = {}

pms_Hyperparameter_index = {k: v for k, v in pms_Hyperparameter_index.items() if v is not None}`;
    await this._py.ex`res_Hyperparameter_index = bridgeHyperparameter[${this.id}].index(**pms_Hyperparameter_index)`;
    return this._py`res_Hyperparameter_index.tolist() if hasattr(res_Hyperparameter_index, 'tolist') else res_Hyperparameter_index`;
  }
};

// src/generated/gaussian_process/kernels/Kernel.ts
import crypto7 from "node:crypto";
var Kernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Kernel${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Kernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Kernel
try: bridgeKernel
except NameError: bridgeKernel = {}
`;
    await this._py.ex`ctor_Kernel = {}

ctor_Kernel = {k: v for k, v in ctor_Kernel.items() if v is not None}`;
    await this._py.ex`bridgeKernel[${this.id}] = Kernel(**ctor_Kernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the kernel.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before __call__()");
    }
    await this._py.ex`pms_Kernel___call__ = {}

pms_Kernel___call__ = {k: v for k, v in pms_Kernel___call__.items() if v is not None}`;
    await this._py.ex`res_Kernel___call__ = bridgeKernel[${this.id}].__call__(**pms_Kernel___call__)`;
    return this._py`res_Kernel___call__.tolist() if hasattr(res_Kernel___call__, 'tolist') else res_Kernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Kernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Kernel_clone_with_theta = {k: v for k, v in pms_Kernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Kernel_clone_with_theta = bridgeKernel[${this.id}].clone_with_theta(**pms_Kernel_clone_with_theta)`;
    return this._py`res_Kernel_clone_with_theta.tolist() if hasattr(res_Kernel_clone_with_theta, 'tolist') else res_Kernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before diag()");
    }
    await this._py.ex`pms_Kernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Kernel_diag = {k: v for k, v in pms_Kernel_diag.items() if v is not None}`;
    await this._py.ex`res_Kernel_diag = bridgeKernel[${this.id}].diag(**pms_Kernel_diag)`;
    return this._py`res_Kernel_diag.tolist() if hasattr(res_Kernel_diag, 'tolist') else res_Kernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Kernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Kernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_Kernel_is_stationary = {}

pms_Kernel_is_stationary = {k: v for k, v in pms_Kernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Kernel_is_stationary = bridgeKernel[${this.id}].is_stationary(**pms_Kernel_is_stationary)`;
    return this._py`res_Kernel_is_stationary.tolist() if hasattr(res_Kernel_is_stationary, 'tolist') else res_Kernel_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/Matern.ts
import crypto8 from "node:crypto";
var Matern = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Matern${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Matern.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Matern
try: bridgeMatern
except NameError: bridgeMatern = {}
`;
    await this._py.ex`ctor_Matern = {'length_scale': np.array(${this.opts["length_scale"] ?? void 0}) if ${this.opts["length_scale"] !== void 0} else None, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'nu': ${this.opts["nu"] ?? void 0}}

ctor_Matern = {k: v for k, v in ctor_Matern.items() if v is not None}`;
    await this._py.ex`bridgeMatern[${this.id}] = Matern(**ctor_Matern)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMatern[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before __call__()");
    }
    await this._py.ex`pms_Matern___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Matern___call__ = {k: v for k, v in pms_Matern___call__.items() if v is not None}`;
    await this._py.ex`res_Matern___call__ = bridgeMatern[${this.id}].__call__(**pms_Matern___call__)`;
    return this._py`res_Matern___call__.tolist() if hasattr(res_Matern___call__, 'tolist') else res_Matern___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Matern_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Matern_clone_with_theta = {k: v for k, v in pms_Matern_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Matern_clone_with_theta = bridgeMatern[${this.id}].clone_with_theta(**pms_Matern_clone_with_theta)`;
    return this._py`res_Matern_clone_with_theta.tolist() if hasattr(res_Matern_clone_with_theta, 'tolist') else res_Matern_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before diag()");
    }
    await this._py.ex`pms_Matern_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Matern_diag = {k: v for k, v in pms_Matern_diag.items() if v is not None}`;
    await this._py.ex`res_Matern_diag = bridgeMatern[${this.id}].diag(**pms_Matern_diag)`;
    return this._py`res_Matern_diag.tolist() if hasattr(res_Matern_diag, 'tolist') else res_Matern_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before is_stationary()");
    }
    await this._py.ex`pms_Matern_is_stationary = {}

pms_Matern_is_stationary = {k: v for k, v in pms_Matern_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Matern_is_stationary = bridgeMatern[${this.id}].is_stationary(**pms_Matern_is_stationary)`;
    return this._py`res_Matern_is_stationary.tolist() if hasattr(res_Matern_is_stationary, 'tolist') else res_Matern_is_stationary`;
  }
  get anisotropic() {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Matern must call init() before accessing anisotropic");
    }
    return (async () => {
      await this._py.ex`attr_Matern_anisotropic = bridgeMatern[${this.id}].anisotropic`;
      return this._py`attr_Matern_anisotropic.tolist() if hasattr(attr_Matern_anisotropic, 'tolist') else attr_Matern_anisotropic`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error("This Matern instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Matern must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_Matern_hyperparameter_length_scale = bridgeMatern[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_Matern_hyperparameter_length_scale.tolist() if hasattr(attr_Matern_hyperparameter_length_scale, 'tolist') else attr_Matern_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/PairwiseKernel.ts
import crypto9 from "node:crypto";
var PairwiseKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `PairwiseKernel${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PairwiseKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import PairwiseKernel
try: bridgePairwiseKernel
except NameError: bridgePairwiseKernel = {}
`;
    await this._py.ex`ctor_PairwiseKernel = {'gamma': ${this.opts["gamma"] ?? void 0}, 'gamma_bounds': ${this.opts["gamma_bounds"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'pairwise_kernels_kwargs': ${this.opts["pairwise_kernels_kwargs"] ?? void 0}}

ctor_PairwiseKernel = {k: v for k, v in ctor_PairwiseKernel.items() if v is not None}`;
    await this._py.ex`bridgePairwiseKernel[${this.id}] = PairwiseKernel(**ctor_PairwiseKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePairwiseKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before __call__()");
    }
    await this._py.ex`pms_PairwiseKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_PairwiseKernel___call__ = {k: v for k, v in pms_PairwiseKernel___call__.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel___call__ = bridgePairwiseKernel[${this.id}].__call__(**pms_PairwiseKernel___call__)`;
    return this._py`res_PairwiseKernel___call__.tolist() if hasattr(res_PairwiseKernel___call__, 'tolist') else res_PairwiseKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PairwiseKernel must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_PairwiseKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_PairwiseKernel_clone_with_theta = {k: v for k, v in pms_PairwiseKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_clone_with_theta = bridgePairwiseKernel[${this.id}].clone_with_theta(**pms_PairwiseKernel_clone_with_theta)`;
    return this._py`res_PairwiseKernel_clone_with_theta.tolist() if hasattr(res_PairwiseKernel_clone_with_theta, 'tolist') else res_PairwiseKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before diag()");
    }
    await this._py.ex`pms_PairwiseKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PairwiseKernel_diag = {k: v for k, v in pms_PairwiseKernel_diag.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_diag = bridgePairwiseKernel[${this.id}].diag(**pms_PairwiseKernel_diag)`;
    return this._py`res_PairwiseKernel_diag.tolist() if hasattr(res_PairwiseKernel_diag, 'tolist') else res_PairwiseKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PairwiseKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_PairwiseKernel_is_stationary = {}

pms_PairwiseKernel_is_stationary = {k: v for k, v in pms_PairwiseKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_PairwiseKernel_is_stationary = bridgePairwiseKernel[${this.id}].is_stationary(**pms_PairwiseKernel_is_stationary)`;
    return this._py`res_PairwiseKernel_is_stationary.tolist() if hasattr(res_PairwiseKernel_is_stationary, 'tolist') else res_PairwiseKernel_is_stationary`;
  }
  get hyperparameter_gamma() {
    if (this._isDisposed) {
      throw new Error("This PairwiseKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PairwiseKernel must call init() before accessing hyperparameter_gamma"
      );
    }
    return (async () => {
      await this._py.ex`attr_PairwiseKernel_hyperparameter_gamma = bridgePairwiseKernel[${this.id}].hyperparameter_gamma`;
      return this._py`attr_PairwiseKernel_hyperparameter_gamma.tolist() if hasattr(attr_PairwiseKernel_hyperparameter_gamma, 'tolist') else attr_PairwiseKernel_hyperparameter_gamma`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Product.ts
import crypto10 from "node:crypto";
var Product = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Product${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Product.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Product
try: bridgeProduct
except NameError: bridgeProduct = {}
`;
    await this._py.ex`ctor_Product = {'k1': ${this.opts["k1"] ?? void 0}, 'k2': ${this.opts["k2"] ?? void 0}}

ctor_Product = {k: v for k, v in ctor_Product.items() if v is not None}`;
    await this._py.ex`bridgeProduct[${this.id}] = Product(**ctor_Product)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeProduct[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before __call__()");
    }
    await this._py.ex`pms_Product___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Product___call__ = {k: v for k, v in pms_Product___call__.items() if v is not None}`;
    await this._py.ex`res_Product___call__ = bridgeProduct[${this.id}].__call__(**pms_Product___call__)`;
    return this._py`res_Product___call__.tolist() if hasattr(res_Product___call__, 'tolist') else res_Product___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Product_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Product_clone_with_theta = {k: v for k, v in pms_Product_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Product_clone_with_theta = bridgeProduct[${this.id}].clone_with_theta(**pms_Product_clone_with_theta)`;
    return this._py`res_Product_clone_with_theta.tolist() if hasattr(res_Product_clone_with_theta, 'tolist') else res_Product_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before diag()");
    }
    await this._py.ex`pms_Product_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Product_diag = {k: v for k, v in pms_Product_diag.items() if v is not None}`;
    await this._py.ex`res_Product_diag = bridgeProduct[${this.id}].diag(**pms_Product_diag)`;
    return this._py`res_Product_diag.tolist() if hasattr(res_Product_diag, 'tolist') else res_Product_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Product instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Product must call init() before is_stationary()");
    }
    await this._py.ex`pms_Product_is_stationary = {}

pms_Product_is_stationary = {k: v for k, v in pms_Product_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Product_is_stationary = bridgeProduct[${this.id}].is_stationary(**pms_Product_is_stationary)`;
    return this._py`res_Product_is_stationary.tolist() if hasattr(res_Product_is_stationary, 'tolist') else res_Product_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/RationalQuadratic.ts
import crypto11 from "node:crypto";
var RationalQuadratic = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RationalQuadratic${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RationalQuadratic.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import RationalQuadratic
try: bridgeRationalQuadratic
except NameError: bridgeRationalQuadratic = {}
`;
    await this._py.ex`ctor_RationalQuadratic = {'length_scale': ${this.opts["length_scale"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}, 'alpha_bounds': ${this.opts["alpha_bounds"] ?? void 0}}

ctor_RationalQuadratic = {k: v for k, v in ctor_RationalQuadratic.items() if v is not None}`;
    await this._py.ex`bridgeRationalQuadratic[${this.id}] = RationalQuadratic(**ctor_RationalQuadratic)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRationalQuadratic[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RationalQuadratic must call init() before __call__()");
    }
    await this._py.ex`pms_RationalQuadratic___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_RationalQuadratic___call__ = {k: v for k, v in pms_RationalQuadratic___call__.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic___call__ = bridgeRationalQuadratic[${this.id}].__call__(**pms_RationalQuadratic___call__)`;
    return this._py`res_RationalQuadratic___call__.tolist() if hasattr(res_RationalQuadratic___call__, 'tolist') else res_RationalQuadratic___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before clone_with_theta()"
      );
    }
    await this._py.ex`pms_RationalQuadratic_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_RationalQuadratic_clone_with_theta = {k: v for k, v in pms_RationalQuadratic_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_clone_with_theta = bridgeRationalQuadratic[${this.id}].clone_with_theta(**pms_RationalQuadratic_clone_with_theta)`;
    return this._py`res_RationalQuadratic_clone_with_theta.tolist() if hasattr(res_RationalQuadratic_clone_with_theta, 'tolist') else res_RationalQuadratic_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RationalQuadratic must call init() before diag()");
    }
    await this._py.ex`pms_RationalQuadratic_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RationalQuadratic_diag = {k: v for k, v in pms_RationalQuadratic_diag.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_diag = bridgeRationalQuadratic[${this.id}].diag(**pms_RationalQuadratic_diag)`;
    return this._py`res_RationalQuadratic_diag.tolist() if hasattr(res_RationalQuadratic_diag, 'tolist') else res_RationalQuadratic_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before is_stationary()"
      );
    }
    await this._py.ex`pms_RationalQuadratic_is_stationary = {}

pms_RationalQuadratic_is_stationary = {k: v for k, v in pms_RationalQuadratic_is_stationary.items() if v is not None}`;
    await this._py.ex`res_RationalQuadratic_is_stationary = bridgeRationalQuadratic[${this.id}].is_stationary(**pms_RationalQuadratic_is_stationary)`;
    return this._py`res_RationalQuadratic_is_stationary.tolist() if hasattr(res_RationalQuadratic_is_stationary, 'tolist') else res_RationalQuadratic_is_stationary`;
  }
  get hyperparameter_alpha() {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before accessing hyperparameter_alpha"
      );
    }
    return (async () => {
      await this._py.ex`attr_RationalQuadratic_hyperparameter_alpha = bridgeRationalQuadratic[${this.id}].hyperparameter_alpha`;
      return this._py`attr_RationalQuadratic_hyperparameter_alpha.tolist() if hasattr(attr_RationalQuadratic_hyperparameter_alpha, 'tolist') else attr_RationalQuadratic_hyperparameter_alpha`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error(
        "This RationalQuadratic instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RationalQuadratic must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_RationalQuadratic_hyperparameter_length_scale = bridgeRationalQuadratic[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_RationalQuadratic_hyperparameter_length_scale.tolist() if hasattr(attr_RationalQuadratic_hyperparameter_length_scale, 'tolist') else attr_RationalQuadratic_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/RBF.ts
import crypto12 from "node:crypto";
var RBF = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RBF${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("RBF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import RBF
try: bridgeRBF
except NameError: bridgeRBF = {}
`;
    await this._py.ex`ctor_RBF = {'length_scale': np.array(${this.opts["length_scale"] ?? void 0}) if ${this.opts["length_scale"] !== void 0} else None, 'length_scale_bounds': ${this.opts["length_scale_bounds"] ?? void 0}}

ctor_RBF = {k: v for k, v in ctor_RBF.items() if v is not None}`;
    await this._py.ex`bridgeRBF[${this.id}] = RBF(**ctor_RBF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRBF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before __call__()");
    }
    await this._py.ex`pms_RBF___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_RBF___call__ = {k: v for k, v in pms_RBF___call__.items() if v is not None}`;
    await this._py.ex`res_RBF___call__ = bridgeRBF[${this.id}].__call__(**pms_RBF___call__)`;
    return this._py`res_RBF___call__.tolist() if hasattr(res_RBF___call__, 'tolist') else res_RBF___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_RBF_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_RBF_clone_with_theta = {k: v for k, v in pms_RBF_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_RBF_clone_with_theta = bridgeRBF[${this.id}].clone_with_theta(**pms_RBF_clone_with_theta)`;
    return this._py`res_RBF_clone_with_theta.tolist() if hasattr(res_RBF_clone_with_theta, 'tolist') else res_RBF_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before diag()");
    }
    await this._py.ex`pms_RBF_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RBF_diag = {k: v for k, v in pms_RBF_diag.items() if v is not None}`;
    await this._py.ex`res_RBF_diag = bridgeRBF[${this.id}].diag(**pms_RBF_diag)`;
    return this._py`res_RBF_diag.tolist() if hasattr(res_RBF_diag, 'tolist') else res_RBF_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before is_stationary()");
    }
    await this._py.ex`pms_RBF_is_stationary = {}

pms_RBF_is_stationary = {k: v for k, v in pms_RBF_is_stationary.items() if v is not None}`;
    await this._py.ex`res_RBF_is_stationary = bridgeRBF[${this.id}].is_stationary(**pms_RBF_is_stationary)`;
    return this._py`res_RBF_is_stationary.tolist() if hasattr(res_RBF_is_stationary, 'tolist') else res_RBF_is_stationary`;
  }
  get anisotropic() {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("RBF must call init() before accessing anisotropic");
    }
    return (async () => {
      await this._py.ex`attr_RBF_anisotropic = bridgeRBF[${this.id}].anisotropic`;
      return this._py`attr_RBF_anisotropic.tolist() if hasattr(attr_RBF_anisotropic, 'tolist') else attr_RBF_anisotropic`;
    })();
  }
  get hyperparameter_length_scale() {
    if (this._isDisposed) {
      throw new Error("This RBF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "RBF must call init() before accessing hyperparameter_length_scale"
      );
    }
    return (async () => {
      await this._py.ex`attr_RBF_hyperparameter_length_scale = bridgeRBF[${this.id}].hyperparameter_length_scale`;
      return this._py`attr_RBF_hyperparameter_length_scale.tolist() if hasattr(attr_RBF_hyperparameter_length_scale, 'tolist') else attr_RBF_hyperparameter_length_scale`;
    })();
  }
};

// src/generated/gaussian_process/kernels/Sum.ts
import crypto13 from "node:crypto";
var Sum = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `Sum${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Sum.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import Sum
try: bridgeSum
except NameError: bridgeSum = {}
`;
    await this._py.ex`ctor_Sum = {'k1': ${this.opts["k1"] ?? void 0}, 'k2': ${this.opts["k2"] ?? void 0}}

ctor_Sum = {k: v for k, v in ctor_Sum.items() if v is not None}`;
    await this._py.ex`bridgeSum[${this.id}] = Sum(**ctor_Sum)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSum[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before __call__()");
    }
    await this._py.ex`pms_Sum___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_Sum___call__ = {k: v for k, v in pms_Sum___call__.items() if v is not None}`;
    await this._py.ex`res_Sum___call__ = bridgeSum[${this.id}].__call__(**pms_Sum___call__)`;
    return this._py`res_Sum___call__.tolist() if hasattr(res_Sum___call__, 'tolist') else res_Sum___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_Sum_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_Sum_clone_with_theta = {k: v for k, v in pms_Sum_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_Sum_clone_with_theta = bridgeSum[${this.id}].clone_with_theta(**pms_Sum_clone_with_theta)`;
    return this._py`res_Sum_clone_with_theta.tolist() if hasattr(res_Sum_clone_with_theta, 'tolist') else res_Sum_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to `np.diag(self(X))`; however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before diag()");
    }
    await this._py.ex`pms_Sum_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Sum_diag = {k: v for k, v in pms_Sum_diag.items() if v is not None}`;
    await this._py.ex`res_Sum_diag = bridgeSum[${this.id}].diag(**pms_Sum_diag)`;
    return this._py`res_Sum_diag.tolist() if hasattr(res_Sum_diag, 'tolist') else res_Sum_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This Sum instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Sum must call init() before is_stationary()");
    }
    await this._py.ex`pms_Sum_is_stationary = {}

pms_Sum_is_stationary = {k: v for k, v in pms_Sum_is_stationary.items() if v is not None}`;
    await this._py.ex`res_Sum_is_stationary = bridgeSum[${this.id}].is_stationary(**pms_Sum_is_stationary)`;
    return this._py`res_Sum_is_stationary.tolist() if hasattr(res_Sum_is_stationary, 'tolist') else res_Sum_is_stationary`;
  }
};

// src/generated/gaussian_process/kernels/WhiteKernel.ts
import crypto14 from "node:crypto";
var WhiteKernel = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `WhiteKernel${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("WhiteKernel.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process.kernels import WhiteKernel
try: bridgeWhiteKernel
except NameError: bridgeWhiteKernel = {}
`;
    await this._py.ex`ctor_WhiteKernel = {'noise_level': ${this.opts["noise_level"] ?? void 0}, 'noise_level_bounds': ${this.opts["noise_level_bounds"] ?? void 0}}

ctor_WhiteKernel = {k: v for k, v in ctor_WhiteKernel.items() if v is not None}`;
    await this._py.ex`bridgeWhiteKernel[${this.id}] = WhiteKernel(**ctor_WhiteKernel)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeWhiteKernel[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Return the kernel k(X, Y) and optionally its gradient.
   */
  async __call__(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before __call__()");
    }
    await this._py.ex`pms_WhiteKernel___call__ = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}}

pms_WhiteKernel___call__ = {k: v for k, v in pms_WhiteKernel___call__.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel___call__ = bridgeWhiteKernel[${this.id}].__call__(**pms_WhiteKernel___call__)`;
    return this._py`res_WhiteKernel___call__.tolist() if hasattr(res_WhiteKernel___call__, 'tolist') else res_WhiteKernel___call__`;
  }
  /**
    Returns a clone of self with given hyperparameters theta.
   */
  async clone_with_theta(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before clone_with_theta()");
    }
    await this._py.ex`pms_WhiteKernel_clone_with_theta = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None}

pms_WhiteKernel_clone_with_theta = {k: v for k, v in pms_WhiteKernel_clone_with_theta.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_clone_with_theta = bridgeWhiteKernel[${this.id}].clone_with_theta(**pms_WhiteKernel_clone_with_theta)`;
    return this._py`res_WhiteKernel_clone_with_theta.tolist() if hasattr(res_WhiteKernel_clone_with_theta, 'tolist') else res_WhiteKernel_clone_with_theta`;
  }
  /**
      Returns the diagonal of the kernel k(X, X).
  
      The result of this method is identical to np.diag(self(X)); however, it can be evaluated more efficiently since only the diagonal is evaluated.
     */
  async diag(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before diag()");
    }
    await this._py.ex`pms_WhiteKernel_diag = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_WhiteKernel_diag = {k: v for k, v in pms_WhiteKernel_diag.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_diag = bridgeWhiteKernel[${this.id}].diag(**pms_WhiteKernel_diag)`;
    return this._py`res_WhiteKernel_diag.tolist() if hasattr(res_WhiteKernel_diag, 'tolist') else res_WhiteKernel_diag`;
  }
  /**
    Returns whether the kernel is stationary.
   */
  async is_stationary(opts) {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("WhiteKernel must call init() before is_stationary()");
    }
    await this._py.ex`pms_WhiteKernel_is_stationary = {}

pms_WhiteKernel_is_stationary = {k: v for k, v in pms_WhiteKernel_is_stationary.items() if v is not None}`;
    await this._py.ex`res_WhiteKernel_is_stationary = bridgeWhiteKernel[${this.id}].is_stationary(**pms_WhiteKernel_is_stationary)`;
    return this._py`res_WhiteKernel_is_stationary.tolist() if hasattr(res_WhiteKernel_is_stationary, 'tolist') else res_WhiteKernel_is_stationary`;
  }
  get hyperparameter_noise_level() {
    if (this._isDisposed) {
      throw new Error("This WhiteKernel instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "WhiteKernel must call init() before accessing hyperparameter_noise_level"
      );
    }
    return (async () => {
      await this._py.ex`attr_WhiteKernel_hyperparameter_noise_level = bridgeWhiteKernel[${this.id}].hyperparameter_noise_level`;
      return this._py`attr_WhiteKernel_hyperparameter_noise_level.tolist() if hasattr(attr_WhiteKernel_hyperparameter_noise_level, 'tolist') else attr_WhiteKernel_hyperparameter_noise_level`;
    })();
  }
};
export {
  CompoundKernel,
  ConstantKernel,
  DotProduct,
  ExpSineSquared,
  Exponentiation,
  Hyperparameter,
  Kernel,
  Matern,
  PairwiseKernel,
  Product,
  RBF,
  RationalQuadratic,
  Sum,
  WhiteKernel
};
//# sourceMappingURL=index.js.map