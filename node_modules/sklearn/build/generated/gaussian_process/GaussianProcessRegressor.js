// src/generated/gaussian_process/GaussianProcessRegressor.ts
import crypto from "node:crypto";
var GaussianProcessRegressor = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianProcessRegressor${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GaussianProcessRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
try: bridgeGaussianProcessRegressor
except NameError: bridgeGaussianProcessRegressor = {}
`;
    await this._py.ex`ctor_GaussianProcessRegressor = {'kernel': ${this.opts["kernel"] ?? void 0}, 'alpha': np.array(${this.opts["alpha"] ?? void 0}) if ${this.opts["alpha"] !== void 0} else None, 'optimizer': ${this.opts["optimizer"] ?? void 0}, 'n_restarts_optimizer': ${this.opts["n_restarts_optimizer"] ?? void 0}, 'normalize_y': ${this.opts["normalize_y"] ?? void 0}, 'copy_X_train': ${this.opts["copy_X_train"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_GaussianProcessRegressor = {k: v for k, v in ctor_GaussianProcessRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGaussianProcessRegressor[${this.id}] = GaussianProcessRegressor(**ctor_GaussianProcessRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianProcessRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit Gaussian process regression model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GaussianProcessRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GaussianProcessRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_GaussianProcessRegressor_fit = {k: v for k, v in pms_GaussianProcessRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_fit = bridgeGaussianProcessRegressor[${this.id}].fit(**pms_GaussianProcessRegressor_fit)`;
    return this._py`res_GaussianProcessRegressor_fit.tolist() if hasattr(res_GaussianProcessRegressor_fit, 'tolist') else res_GaussianProcessRegressor_fit`;
  }
  /**
    Return log-marginal likelihood of theta for training data.
   */
  async log_marginal_likelihood(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before log_marginal_likelihood()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_log_marginal_likelihood = {'theta': np.array(${opts["theta"] ?? void 0}) if ${opts["theta"] !== void 0} else None, 'eval_gradient': ${opts["eval_gradient"] ?? void 0}, 'clone_kernel': ${opts["clone_kernel"] ?? void 0}}

pms_GaussianProcessRegressor_log_marginal_likelihood = {k: v for k, v in pms_GaussianProcessRegressor_log_marginal_likelihood.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_log_marginal_likelihood = bridgeGaussianProcessRegressor[${this.id}].log_marginal_likelihood(**pms_GaussianProcessRegressor_log_marginal_likelihood)`;
    return this._py`res_GaussianProcessRegressor_log_marginal_likelihood.tolist() if hasattr(res_GaussianProcessRegressor_log_marginal_likelihood, 'tolist') else res_GaussianProcessRegressor_log_marginal_likelihood`;
  }
  /**
      Predict using the Gaussian process regression model.
  
      We can also predict based on an unfitted model by using the GP prior. In addition to the mean of the predictive distribution, optionally also returns its standard deviation (`return\_std=True`) or covariance (`return\_cov=True`). Note that at most one of the two can be requested.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}, 'return_cov': ${opts["return_cov"] ?? void 0}}

pms_GaussianProcessRegressor_predict = {k: v for k, v in pms_GaussianProcessRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_predict = bridgeGaussianProcessRegressor[${this.id}].predict(**pms_GaussianProcessRegressor_predict)`;
    return this._py`res_GaussianProcessRegressor_predict.tolist() if hasattr(res_GaussianProcessRegressor_predict, 'tolist') else res_GaussianProcessRegressor_predict`;
  }
  /**
    Draw samples from Gaussian process and evaluate at X.
   */
  async sample_y(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before sample_y()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_sample_y = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'n_samples': ${opts["n_samples"] ?? void 0}, 'random_state': ${opts["random_state"] ?? void 0}}

pms_GaussianProcessRegressor_sample_y = {k: v for k, v in pms_GaussianProcessRegressor_sample_y.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_sample_y = bridgeGaussianProcessRegressor[${this.id}].sample_y(**pms_GaussianProcessRegressor_sample_y)`;
    return this._py`res_GaussianProcessRegressor_sample_y.tolist() if hasattr(res_GaussianProcessRegressor_sample_y, 'tolist') else res_GaussianProcessRegressor_sample_y`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_GaussianProcessRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GaussianProcessRegressor_score = {k: v for k, v in pms_GaussianProcessRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GaussianProcessRegressor_score = bridgeGaussianProcessRegressor[${this.id}].score(**pms_GaussianProcessRegressor_score)`;
    return this._py`res_GaussianProcessRegressor_score.tolist() if hasattr(res_GaussianProcessRegressor_score, 'tolist') else res_GaussianProcessRegressor_score`;
  }
  /**
    Feature vectors or other representations of training data (also required for prediction).
   */
  get X_train_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing X_train_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_X_train_ = bridgeGaussianProcessRegressor[${this.id}].X_train_`;
      return this._py`attr_GaussianProcessRegressor_X_train_.tolist() if hasattr(attr_GaussianProcessRegressor_X_train_, 'tolist') else attr_GaussianProcessRegressor_X_train_`;
    })();
  }
  /**
    Target values in training data (also required for prediction).
   */
  get y_train_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing y_train_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_y_train_ = bridgeGaussianProcessRegressor[${this.id}].y_train_`;
      return this._py`attr_GaussianProcessRegressor_y_train_.tolist() if hasattr(attr_GaussianProcessRegressor_y_train_, 'tolist') else attr_GaussianProcessRegressor_y_train_`;
    })();
  }
  /**
    The kernel used for prediction. The structure of the kernel is the same as the one passed as parameter but with optimized hyperparameters.
   */
  get kernel_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing kernel_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_kernel_ = bridgeGaussianProcessRegressor[${this.id}].kernel_`;
      return this._py`attr_GaussianProcessRegressor_kernel_.tolist() if hasattr(attr_GaussianProcessRegressor_kernel_, 'tolist') else attr_GaussianProcessRegressor_kernel_`;
    })();
  }
  /**
    Lower-triangular Cholesky decomposition of the kernel in `X\_train\_`.
   */
  get L_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing L_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_L_ = bridgeGaussianProcessRegressor[${this.id}].L_`;
      return this._py`attr_GaussianProcessRegressor_L_.tolist() if hasattr(attr_GaussianProcessRegressor_L_, 'tolist') else attr_GaussianProcessRegressor_L_`;
    })();
  }
  /**
    Dual coefficients of training data points in kernel space.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_alpha_ = bridgeGaussianProcessRegressor[${this.id}].alpha_`;
      return this._py`attr_GaussianProcessRegressor_alpha_.tolist() if hasattr(attr_GaussianProcessRegressor_alpha_, 'tolist') else attr_GaussianProcessRegressor_alpha_`;
    })();
  }
  /**
    The log-marginal-likelihood of `self.kernel\_.theta`.
   */
  get log_marginal_likelihood_value_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing log_marginal_likelihood_value_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_log_marginal_likelihood_value_ = bridgeGaussianProcessRegressor[${this.id}].log_marginal_likelihood_value_`;
      return this._py`attr_GaussianProcessRegressor_log_marginal_likelihood_value_.tolist() if hasattr(attr_GaussianProcessRegressor_log_marginal_likelihood_value_, 'tolist') else attr_GaussianProcessRegressor_log_marginal_likelihood_value_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_n_features_in_ = bridgeGaussianProcessRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GaussianProcessRegressor_n_features_in_.tolist() if hasattr(attr_GaussianProcessRegressor_n_features_in_, 'tolist') else attr_GaussianProcessRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GaussianProcessRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianProcessRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianProcessRegressor_feature_names_in_ = bridgeGaussianProcessRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianProcessRegressor_feature_names_in_.tolist() if hasattr(attr_GaussianProcessRegressor_feature_names_in_, 'tolist') else attr_GaussianProcessRegressor_feature_names_in_`;
    })();
  }
};
export {
  GaussianProcessRegressor
};
//# sourceMappingURL=GaussianProcessRegressor.js.map