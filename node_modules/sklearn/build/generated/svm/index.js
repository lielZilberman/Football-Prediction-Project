// src/generated/svm/LinearSVC.ts
import crypto from "node:crypto";
var LinearSVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearSVC${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LinearSVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import LinearSVC
try: bridgeLinearSVC
except NameError: bridgeLinearSVC = {}
`;
    await this._py.ex`ctor_LinearSVC = {'penalty': ${this.opts["penalty"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'multi_class': ${this.opts["multi_class"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_LinearSVC = {k: v for k, v in ctor_LinearSVC.items() if v is not None}`;
    await this._py.ex`bridgeLinearSVC[${this.id}] = LinearSVC(**ctor_LinearSVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Predict confidence scores for samples.
  
      The confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before decision_function()");
    }
    await this._py.ex`pms_LinearSVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearSVC_decision_function = {k: v for k, v in pms_LinearSVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_decision_function = bridgeLinearSVC[${this.id}].decision_function(**pms_LinearSVC_decision_function)`;
    return this._py`res_LinearSVC_decision_function.tolist() if hasattr(res_LinearSVC_decision_function, 'tolist') else res_LinearSVC_decision_function`;
  }
  /**
      Convert coefficient matrix to dense array format.
  
      Converts the `coef\_` member (back) to a numpy.ndarray. This is the default format of `coef\_` and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.
     */
  async densify(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before densify()");
    }
    await this._py.ex`pms_LinearSVC_densify = {}

pms_LinearSVC_densify = {k: v for k, v in pms_LinearSVC_densify.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_densify = bridgeLinearSVC[${this.id}].densify(**pms_LinearSVC_densify)`;
    return this._py`res_LinearSVC_densify.tolist() if hasattr(res_LinearSVC_densify, 'tolist') else res_LinearSVC_densify`;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before fit()");
    }
    await this._py.ex`pms_LinearSVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVC_fit = {k: v for k, v in pms_LinearSVC_fit.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_fit = bridgeLinearSVC[${this.id}].fit(**pms_LinearSVC_fit)`;
    return this._py`res_LinearSVC_fit.tolist() if hasattr(res_LinearSVC_fit, 'tolist') else res_LinearSVC_fit`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before predict()");
    }
    await this._py.ex`pms_LinearSVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearSVC_predict = {k: v for k, v in pms_LinearSVC_predict.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_predict = bridgeLinearSVC[${this.id}].predict(**pms_LinearSVC_predict)`;
    return this._py`res_LinearSVC_predict.tolist() if hasattr(res_LinearSVC_predict, 'tolist') else res_LinearSVC_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before score()");
    }
    await this._py.ex`pms_LinearSVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVC_score = {k: v for k, v in pms_LinearSVC_score.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_score = bridgeLinearSVC[${this.id}].score(**pms_LinearSVC_score)`;
    return this._py`res_LinearSVC_score.tolist() if hasattr(res_LinearSVC_score, 'tolist') else res_LinearSVC_score`;
  }
  /**
      Convert coefficient matrix to sparse format.
  
      Converts the `coef\_` member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.
  
      The `intercept\_` member is not converted.
     */
  async sparsify(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before sparsify()");
    }
    await this._py.ex`pms_LinearSVC_sparsify = {}

pms_LinearSVC_sparsify = {k: v for k, v in pms_LinearSVC_sparsify.items() if v is not None}`;
    await this._py.ex`res_LinearSVC_sparsify = bridgeLinearSVC[${this.id}].sparsify(**pms_LinearSVC_sparsify)`;
    return this._py`res_LinearSVC_sparsify.tolist() if hasattr(res_LinearSVC_sparsify, 'tolist') else res_LinearSVC_sparsify`;
  }
  /**
      Weights assigned to the features (coefficients in the primal problem).
  
      `coef\_` is a readonly property derived from `raw\_coef\_` that follows the internal memory layout of liblinear.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_coef_ = bridgeLinearSVC[${this.id}].coef_`;
      return this._py`attr_LinearSVC_coef_.tolist() if hasattr(attr_LinearSVC_coef_, 'tolist') else attr_LinearSVC_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_intercept_ = bridgeLinearSVC[${this.id}].intercept_`;
      return this._py`attr_LinearSVC_intercept_.tolist() if hasattr(attr_LinearSVC_intercept_, 'tolist') else attr_LinearSVC_intercept_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_classes_ = bridgeLinearSVC[${this.id}].classes_`;
      return this._py`attr_LinearSVC_classes_.tolist() if hasattr(attr_LinearSVC_classes_, 'tolist') else attr_LinearSVC_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVC must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_n_features_in_ = bridgeLinearSVC[${this.id}].n_features_in_`;
      return this._py`attr_LinearSVC_n_features_in_.tolist() if hasattr(attr_LinearSVC_n_features_in_, 'tolist') else attr_LinearSVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVC must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_feature_names_in_ = bridgeLinearSVC[${this.id}].feature_names_in_`;
      return this._py`attr_LinearSVC_feature_names_in_.tolist() if hasattr(attr_LinearSVC_feature_names_in_, 'tolist') else attr_LinearSVC_feature_names_in_`;
    })();
  }
  /**
    Maximum number of iterations run across all classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVC_n_iter_ = bridgeLinearSVC[${this.id}].n_iter_`;
      return this._py`attr_LinearSVC_n_iter_.tolist() if hasattr(attr_LinearSVC_n_iter_, 'tolist') else attr_LinearSVC_n_iter_`;
    })();
  }
};

// src/generated/svm/LinearSVR.ts
import crypto2 from "node:crypto";
var LinearSVR = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `LinearSVR${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LinearSVR.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import LinearSVR
try: bridgeLinearSVR
except NameError: bridgeLinearSVR = {}
`;
    await this._py.ex`ctor_LinearSVR = {'epsilon': ${this.opts["epsilon"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'fit_intercept': ${this.opts["fit_intercept"] ?? void 0}, 'intercept_scaling': ${this.opts["intercept_scaling"] ?? void 0}, 'dual': ${this.opts["dual"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_LinearSVR = {k: v for k, v in ctor_LinearSVR.items() if v is not None}`;
    await this._py.ex`bridgeLinearSVR[${this.id}] = LinearSVR(**ctor_LinearSVR)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearSVR[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before fit()");
    }
    await this._py.ex`pms_LinearSVR_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVR_fit = {k: v for k, v in pms_LinearSVR_fit.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_fit = bridgeLinearSVR[${this.id}].fit(**pms_LinearSVR_fit)`;
    return this._py`res_LinearSVR_fit.tolist() if hasattr(res_LinearSVR_fit, 'tolist') else res_LinearSVR_fit`;
  }
  /**
    Predict using the linear model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before predict()");
    }
    await this._py.ex`pms_LinearSVR_predict = {'X': ${opts["X"] ?? void 0}}

pms_LinearSVR_predict = {k: v for k, v in pms_LinearSVR_predict.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_predict = bridgeLinearSVR[${this.id}].predict(**pms_LinearSVR_predict)`;
    return this._py`res_LinearSVR_predict.tolist() if hasattr(res_LinearSVR_predict, 'tolist') else res_LinearSVR_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before score()");
    }
    await this._py.ex`pms_LinearSVR_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearSVR_score = {k: v for k, v in pms_LinearSVR_score.items() if v is not None}`;
    await this._py.ex`res_LinearSVR_score = bridgeLinearSVR[${this.id}].score(**pms_LinearSVR_score)`;
    return this._py`res_LinearSVR_score.tolist() if hasattr(res_LinearSVR_score, 'tolist') else res_LinearSVR_score`;
  }
  /**
      Weights assigned to the features (coefficients in the primal problem).
  
      `coef\_` is a readonly property derived from `raw\_coef\_` that follows the internal memory layout of liblinear.
     */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_coef_ = bridgeLinearSVR[${this.id}].coef_`;
      return this._py`attr_LinearSVR_coef_.tolist() if hasattr(attr_LinearSVR_coef_, 'tolist') else attr_LinearSVR_coef_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_intercept_ = bridgeLinearSVR[${this.id}].intercept_`;
      return this._py`attr_LinearSVR_intercept_.tolist() if hasattr(attr_LinearSVR_intercept_, 'tolist') else attr_LinearSVR_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVR must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_n_features_in_ = bridgeLinearSVR[${this.id}].n_features_in_`;
      return this._py`attr_LinearSVR_n_features_in_.tolist() if hasattr(attr_LinearSVR_n_features_in_, 'tolist') else attr_LinearSVR_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearSVR must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_feature_names_in_ = bridgeLinearSVR[${this.id}].feature_names_in_`;
      return this._py`attr_LinearSVR_feature_names_in_.tolist() if hasattr(attr_LinearSVR_feature_names_in_, 'tolist') else attr_LinearSVR_feature_names_in_`;
    })();
  }
  /**
    Maximum number of iterations run across all classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This LinearSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LinearSVR must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_LinearSVR_n_iter_ = bridgeLinearSVR[${this.id}].n_iter_`;
      return this._py`attr_LinearSVR_n_iter_.tolist() if hasattr(attr_LinearSVR_n_iter_, 'tolist') else attr_LinearSVR_n_iter_`;
    })();
  }
};

// src/generated/svm/NuSVC.ts
import crypto3 from "node:crypto";
var NuSVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NuSVC${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NuSVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import NuSVC
try: bridgeNuSVC
except NameError: bridgeNuSVC = {}
`;
    await this._py.ex`ctor_NuSVC = {'nu': ${this.opts["nu"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'probability': ${this.opts["probability"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'decision_function_shape': ${this.opts["decision_function_shape"] ?? void 0}, 'break_ties': ${this.opts["break_ties"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_NuSVC = {k: v for k, v in ctor_NuSVC.items() if v is not None}`;
    await this._py.ex`bridgeNuSVC[${this.id}] = NuSVC(**ctor_NuSVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNuSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the decision function for the samples in X.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before decision_function()");
    }
    await this._py.ex`pms_NuSVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_decision_function = {k: v for k, v in pms_NuSVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_NuSVC_decision_function = bridgeNuSVC[${this.id}].decision_function(**pms_NuSVC_decision_function)`;
    return this._py`res_NuSVC_decision_function.tolist() if hasattr(res_NuSVC_decision_function, 'tolist') else res_NuSVC_decision_function`;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before fit()");
    }
    await this._py.ex`pms_NuSVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVC_fit = {k: v for k, v in pms_NuSVC_fit.items() if v is not None}`;
    await this._py.ex`res_NuSVC_fit = bridgeNuSVC[${this.id}].fit(**pms_NuSVC_fit)`;
    return this._py`res_NuSVC_fit.tolist() if hasattr(res_NuSVC_fit, 'tolist') else res_NuSVC_fit`;
  }
  /**
      Perform classification on samples in X.
  
      For an one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before predict()");
    }
    await this._py.ex`pms_NuSVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_predict = {k: v for k, v in pms_NuSVC_predict.items() if v is not None}`;
    await this._py.ex`res_NuSVC_predict = bridgeNuSVC[${this.id}].predict(**pms_NuSVC_predict)`;
    return this._py`res_NuSVC_predict.tolist() if hasattr(res_NuSVC_predict, 'tolist') else res_NuSVC_predict`;
  }
  /**
      Compute log probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_NuSVC_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_predict_log_proba = {k: v for k, v in pms_NuSVC_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_NuSVC_predict_log_proba = bridgeNuSVC[${this.id}].predict_log_proba(**pms_NuSVC_predict_log_proba)`;
    return this._py`res_NuSVC_predict_log_proba.tolist() if hasattr(res_NuSVC_predict_log_proba, 'tolist') else res_NuSVC_predict_log_proba`;
  }
  /**
      Compute probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before predict_proba()");
    }
    await this._py.ex`pms_NuSVC_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVC_predict_proba = {k: v for k, v in pms_NuSVC_predict_proba.items() if v is not None}`;
    await this._py.ex`res_NuSVC_predict_proba = bridgeNuSVC[${this.id}].predict_proba(**pms_NuSVC_predict_proba)`;
    return this._py`res_NuSVC_predict_proba.tolist() if hasattr(res_NuSVC_predict_proba, 'tolist') else res_NuSVC_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before score()");
    }
    await this._py.ex`pms_NuSVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVC_score = {k: v for k, v in pms_NuSVC_score.items() if v is not None}`;
    await this._py.ex`res_NuSVC_score = bridgeNuSVC[${this.id}].score(**pms_NuSVC_score)`;
    return this._py`res_NuSVC_score.tolist() if hasattr(res_NuSVC_score, 'tolist') else res_NuSVC_score`;
  }
  /**
    Multipliers of parameter C of each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_class_weight_ = bridgeNuSVC[${this.id}].class_weight_`;
      return this._py`attr_NuSVC_class_weight_.tolist() if hasattr(attr_NuSVC_class_weight_, 'tolist') else attr_NuSVC_class_weight_`;
    })();
  }
  /**
    The unique classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_classes_ = bridgeNuSVC[${this.id}].classes_`;
      return this._py`attr_NuSVC_classes_.tolist() if hasattr(attr_NuSVC_classes_, 'tolist') else attr_NuSVC_classes_`;
    })();
  }
  /**
    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_dual_coef_ = bridgeNuSVC[${this.id}].dual_coef_`;
      return this._py`attr_NuSVC_dual_coef_.tolist() if hasattr(attr_NuSVC_dual_coef_, 'tolist') else attr_NuSVC_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 if the algorithm did not converge.
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_fit_status_ = bridgeNuSVC[${this.id}].fit_status_`;
      return this._py`attr_NuSVC_fit_status_.tolist() if hasattr(attr_NuSVC_fit_status_, 'tolist') else attr_NuSVC_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_intercept_ = bridgeNuSVC[${this.id}].intercept_`;
      return this._py`attr_NuSVC_intercept_.tolist() if hasattr(attr_NuSVC_intercept_, 'tolist') else attr_NuSVC_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_n_features_in_ = bridgeNuSVC[${this.id}].n_features_in_`;
      return this._py`attr_NuSVC_n_features_in_.tolist() if hasattr(attr_NuSVC_n_features_in_, 'tolist') else attr_NuSVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVC must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_feature_names_in_ = bridgeNuSVC[${this.id}].feature_names_in_`;
      return this._py`attr_NuSVC_feature_names_in_.tolist() if hasattr(attr_NuSVC_feature_names_in_, 'tolist') else attr_NuSVC_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_n_iter_ = bridgeNuSVC[${this.id}].n_iter_`;
      return this._py`attr_NuSVC_n_iter_.tolist() if hasattr(attr_NuSVC_n_iter_, 'tolist') else attr_NuSVC_n_iter_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_support_ = bridgeNuSVC[${this.id}].support_`;
      return this._py`attr_NuSVC_support_.tolist() if hasattr(attr_NuSVC_support_, 'tolist') else attr_NuSVC_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVC must call init() before accessing support_vectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_support_vectors_ = bridgeNuSVC[${this.id}].support_vectors_`;
      return this._py`attr_NuSVC_support_vectors_.tolist() if hasattr(attr_NuSVC_support_vectors_, 'tolist') else attr_NuSVC_support_vectors_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This NuSVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVC must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVC_shape_fit_ = bridgeNuSVC[${this.id}].shape_fit_`;
      return this._py`attr_NuSVC_shape_fit_.tolist() if hasattr(attr_NuSVC_shape_fit_, 'tolist') else attr_NuSVC_shape_fit_`;
    })();
  }
};

// src/generated/svm/NuSVR.ts
import crypto4 from "node:crypto";
var NuSVR = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `NuSVR${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NuSVR.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import NuSVR
try: bridgeNuSVR
except NameError: bridgeNuSVR = {}
`;
    await this._py.ex`ctor_NuSVR = {'nu': ${this.opts["nu"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_NuSVR = {k: v for k, v in ctor_NuSVR.items() if v is not None}`;
    await this._py.ex`bridgeNuSVR[${this.id}] = NuSVR(**ctor_NuSVR)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNuSVR[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before fit()");
    }
    await this._py.ex`pms_NuSVR_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVR_fit = {k: v for k, v in pms_NuSVR_fit.items() if v is not None}`;
    await this._py.ex`res_NuSVR_fit = bridgeNuSVR[${this.id}].fit(**pms_NuSVR_fit)`;
    return this._py`res_NuSVR_fit.tolist() if hasattr(res_NuSVR_fit, 'tolist') else res_NuSVR_fit`;
  }
  /**
      Perform regression on samples in X.
  
      For an one-class model, +1 (inlier) or -1 (outlier) is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before predict()");
    }
    await this._py.ex`pms_NuSVR_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NuSVR_predict = {k: v for k, v in pms_NuSVR_predict.items() if v is not None}`;
    await this._py.ex`res_NuSVR_predict = bridgeNuSVR[${this.id}].predict(**pms_NuSVR_predict)`;
    return this._py`res_NuSVR_predict.tolist() if hasattr(res_NuSVR_predict, 'tolist') else res_NuSVR_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before score()");
    }
    await this._py.ex`pms_NuSVR_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_NuSVR_score = {k: v for k, v in pms_NuSVR_score.items() if v is not None}`;
    await this._py.ex`res_NuSVR_score = bridgeNuSVR[${this.id}].score(**pms_NuSVR_score)`;
    return this._py`res_NuSVR_score.tolist() if hasattr(res_NuSVR_score, 'tolist') else res_NuSVR_score`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_class_weight_ = bridgeNuSVR[${this.id}].class_weight_`;
      return this._py`attr_NuSVR_class_weight_.tolist() if hasattr(attr_NuSVR_class_weight_, 'tolist') else attr_NuSVR_class_weight_`;
    })();
  }
  /**
    Coefficients of the support vector in the decision function.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_dual_coef_ = bridgeNuSVR[${this.id}].dual_coef_`;
      return this._py`attr_NuSVR_dual_coef_.tolist() if hasattr(attr_NuSVR_dual_coef_, 'tolist') else attr_NuSVR_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_fit_status_ = bridgeNuSVR[${this.id}].fit_status_`;
      return this._py`attr_NuSVR_fit_status_.tolist() if hasattr(attr_NuSVR_fit_status_, 'tolist') else attr_NuSVR_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_intercept_ = bridgeNuSVR[${this.id}].intercept_`;
      return this._py`attr_NuSVR_intercept_.tolist() if hasattr(attr_NuSVR_intercept_, 'tolist') else attr_NuSVR_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_n_features_in_ = bridgeNuSVR[${this.id}].n_features_in_`;
      return this._py`attr_NuSVR_n_features_in_.tolist() if hasattr(attr_NuSVR_n_features_in_, 'tolist') else attr_NuSVR_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVR must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_feature_names_in_ = bridgeNuSVR[${this.id}].feature_names_in_`;
      return this._py`attr_NuSVR_feature_names_in_.tolist() if hasattr(attr_NuSVR_feature_names_in_, 'tolist') else attr_NuSVR_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_n_iter_ = bridgeNuSVR[${this.id}].n_iter_`;
      return this._py`attr_NuSVR_n_iter_.tolist() if hasattr(attr_NuSVR_n_iter_, 'tolist') else attr_NuSVR_n_iter_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_shape_fit_ = bridgeNuSVR[${this.id}].shape_fit_`;
      return this._py`attr_NuSVR_shape_fit_.tolist() if hasattr(attr_NuSVR_shape_fit_, 'tolist') else attr_NuSVR_shape_fit_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NuSVR must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_support_ = bridgeNuSVR[${this.id}].support_`;
      return this._py`attr_NuSVR_support_.tolist() if hasattr(attr_NuSVR_support_, 'tolist') else attr_NuSVR_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This NuSVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NuSVR must call init() before accessing support_vectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NuSVR_support_vectors_ = bridgeNuSVR[${this.id}].support_vectors_`;
      return this._py`attr_NuSVR_support_vectors_.tolist() if hasattr(attr_NuSVR_support_vectors_, 'tolist') else attr_NuSVR_support_vectors_`;
    })();
  }
};

// src/generated/svm/OneClassSVM.ts
import crypto5 from "node:crypto";
var OneClassSVM = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneClassSVM${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OneClassSVM.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import OneClassSVM
try: bridgeOneClassSVM
except NameError: bridgeOneClassSVM = {}
`;
    await this._py.ex`ctor_OneClassSVM = {'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'nu': ${this.opts["nu"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_OneClassSVM = {k: v for k, v in ctor_OneClassSVM.items() if v is not None}`;
    await this._py.ex`bridgeOneClassSVM[${this.id}] = OneClassSVM(**ctor_OneClassSVM)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneClassSVM[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Signed distance to the separating hyperplane.
  
      Signed distance is positive for an inlier and negative for an outlier.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before decision_function()");
    }
    await this._py.ex`pms_OneClassSVM_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneClassSVM_decision_function = {k: v for k, v in pms_OneClassSVM_decision_function.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_decision_function = bridgeOneClassSVM[${this.id}].decision_function(**pms_OneClassSVM_decision_function)`;
    return this._py`res_OneClassSVM_decision_function.tolist() if hasattr(res_OneClassSVM_decision_function, 'tolist') else res_OneClassSVM_decision_function`;
  }
  /**
    Detect the soft boundary of the set of samples X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before fit()");
    }
    await this._py.ex`pms_OneClassSVM_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OneClassSVM_fit = {k: v for k, v in pms_OneClassSVM_fit.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_fit = bridgeOneClassSVM[${this.id}].fit(**pms_OneClassSVM_fit)`;
    return this._py`res_OneClassSVM_fit.tolist() if hasattr(res_OneClassSVM_fit, 'tolist') else res_OneClassSVM_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before fit_predict()");
    }
    await this._py.ex`pms_OneClassSVM_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OneClassSVM_fit_predict = {k: v for k, v in pms_OneClassSVM_fit_predict.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_fit_predict = bridgeOneClassSVM[${this.id}].fit_predict(**pms_OneClassSVM_fit_predict)`;
    return this._py`res_OneClassSVM_fit_predict.tolist() if hasattr(res_OneClassSVM_fit_predict, 'tolist') else res_OneClassSVM_fit_predict`;
  }
  /**
      Perform classification on samples in X.
  
      For a one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before predict()");
    }
    await this._py.ex`pms_OneClassSVM_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneClassSVM_predict = {k: v for k, v in pms_OneClassSVM_predict.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_predict = bridgeOneClassSVM[${this.id}].predict(**pms_OneClassSVM_predict)`;
    return this._py`res_OneClassSVM_predict.tolist() if hasattr(res_OneClassSVM_predict, 'tolist') else res_OneClassSVM_predict`;
  }
  /**
    Raw scoring function of the samples.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before score_samples()");
    }
    await this._py.ex`pms_OneClassSVM_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneClassSVM_score_samples = {k: v for k, v in pms_OneClassSVM_score_samples.items() if v is not None}`;
    await this._py.ex`res_OneClassSVM_score_samples = bridgeOneClassSVM[${this.id}].score_samples(**pms_OneClassSVM_score_samples)`;
    return this._py`res_OneClassSVM_score_samples.tolist() if hasattr(res_OneClassSVM_score_samples, 'tolist') else res_OneClassSVM_score_samples`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing class_weight_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_class_weight_ = bridgeOneClassSVM[${this.id}].class_weight_`;
      return this._py`attr_OneClassSVM_class_weight_.tolist() if hasattr(attr_OneClassSVM_class_weight_, 'tolist') else attr_OneClassSVM_class_weight_`;
    })();
  }
  /**
    Coefficients of the support vectors in the decision function.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing dual_coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_dual_coef_ = bridgeOneClassSVM[${this.id}].dual_coef_`;
      return this._py`attr_OneClassSVM_dual_coef_.tolist() if hasattr(attr_OneClassSVM_dual_coef_, 'tolist') else attr_OneClassSVM_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing fit_status_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_fit_status_ = bridgeOneClassSVM[${this.id}].fit_status_`;
      return this._py`attr_OneClassSVM_fit_status_.tolist() if hasattr(attr_OneClassSVM_fit_status_, 'tolist') else attr_OneClassSVM_fit_status_`;
    })();
  }
  /**
    Constant in the decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_intercept_ = bridgeOneClassSVM[${this.id}].intercept_`;
      return this._py`attr_OneClassSVM_intercept_.tolist() if hasattr(attr_OneClassSVM_intercept_, 'tolist') else attr_OneClassSVM_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_n_features_in_ = bridgeOneClassSVM[${this.id}].n_features_in_`;
      return this._py`attr_OneClassSVM_n_features_in_.tolist() if hasattr(attr_OneClassSVM_n_features_in_, 'tolist') else attr_OneClassSVM_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_feature_names_in_ = bridgeOneClassSVM[${this.id}].feature_names_in_`;
      return this._py`attr_OneClassSVM_feature_names_in_.tolist() if hasattr(attr_OneClassSVM_feature_names_in_, 'tolist') else attr_OneClassSVM_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_n_iter_ = bridgeOneClassSVM[${this.id}].n_iter_`;
      return this._py`attr_OneClassSVM_n_iter_.tolist() if hasattr(attr_OneClassSVM_n_iter_, 'tolist') else attr_OneClassSVM_n_iter_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: decision\_function = score\_samples - `offset\_`. The offset is the opposite of `intercept\_` and is provided for consistency with other outlier detection algorithms.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before accessing offset_");
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_offset_ = bridgeOneClassSVM[${this.id}].offset_`;
      return this._py`attr_OneClassSVM_offset_.tolist() if hasattr(attr_OneClassSVM_offset_, 'tolist') else attr_OneClassSVM_offset_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing shape_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_shape_fit_ = bridgeOneClassSVM[${this.id}].shape_fit_`;
      return this._py`attr_OneClassSVM_shape_fit_.tolist() if hasattr(attr_OneClassSVM_shape_fit_, 'tolist') else attr_OneClassSVM_shape_fit_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OneClassSVM must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_support_ = bridgeOneClassSVM[${this.id}].support_`;
      return this._py`attr_OneClassSVM_support_.tolist() if hasattr(attr_OneClassSVM_support_, 'tolist') else attr_OneClassSVM_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This OneClassSVM instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneClassSVM must call init() before accessing support_vectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneClassSVM_support_vectors_ = bridgeOneClassSVM[${this.id}].support_vectors_`;
      return this._py`attr_OneClassSVM_support_vectors_.tolist() if hasattr(attr_OneClassSVM_support_vectors_, 'tolist') else attr_OneClassSVM_support_vectors_`;
    })();
  }
};

// src/generated/svm/SVC.ts
import crypto6 from "node:crypto";
var SVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SVC${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import SVC
try: bridgeSVC
except NameError: bridgeSVC = {}
`;
    await this._py.ex`ctor_SVC = {'C': ${this.opts["C"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'probability': ${this.opts["probability"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'decision_function_shape': ${this.opts["decision_function_shape"] ?? void 0}, 'break_ties': ${this.opts["break_ties"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SVC = {k: v for k, v in ctor_SVC.items() if v is not None}`;
    await this._py.ex`bridgeSVC[${this.id}] = SVC(**ctor_SVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the decision function for the samples in X.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before decision_function()");
    }
    await this._py.ex`pms_SVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_decision_function = {k: v for k, v in pms_SVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_SVC_decision_function = bridgeSVC[${this.id}].decision_function(**pms_SVC_decision_function)`;
    return this._py`res_SVC_decision_function.tolist() if hasattr(res_SVC_decision_function, 'tolist') else res_SVC_decision_function`;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before fit()");
    }
    await this._py.ex`pms_SVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVC_fit = {k: v for k, v in pms_SVC_fit.items() if v is not None}`;
    await this._py.ex`res_SVC_fit = bridgeSVC[${this.id}].fit(**pms_SVC_fit)`;
    return this._py`res_SVC_fit.tolist() if hasattr(res_SVC_fit, 'tolist') else res_SVC_fit`;
  }
  /**
      Perform classification on samples in X.
  
      For an one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict()");
    }
    await this._py.ex`pms_SVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict = {k: v for k, v in pms_SVC_predict.items() if v is not None}`;
    await this._py.ex`res_SVC_predict = bridgeSVC[${this.id}].predict(**pms_SVC_predict)`;
    return this._py`res_SVC_predict.tolist() if hasattr(res_SVC_predict, 'tolist') else res_SVC_predict`;
  }
  /**
      Compute log probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_SVC_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict_log_proba = {k: v for k, v in pms_SVC_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_SVC_predict_log_proba = bridgeSVC[${this.id}].predict_log_proba(**pms_SVC_predict_log_proba)`;
    return this._py`res_SVC_predict_log_proba.tolist() if hasattr(res_SVC_predict_log_proba, 'tolist') else res_SVC_predict_log_proba`;
  }
  /**
      Compute probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict_proba()");
    }
    await this._py.ex`pms_SVC_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict_proba = {k: v for k, v in pms_SVC_predict_proba.items() if v is not None}`;
    await this._py.ex`res_SVC_predict_proba = bridgeSVC[${this.id}].predict_proba(**pms_SVC_predict_proba)`;
    return this._py`res_SVC_predict_proba.tolist() if hasattr(res_SVC_predict_proba, 'tolist') else res_SVC_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before score()");
    }
    await this._py.ex`pms_SVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVC_score = {k: v for k, v in pms_SVC_score.items() if v is not None}`;
    await this._py.ex`res_SVC_score = bridgeSVC[${this.id}].score(**pms_SVC_score)`;
    return this._py`res_SVC_score.tolist() if hasattr(res_SVC_score, 'tolist') else res_SVC_score`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_class_weight_ = bridgeSVC[${this.id}].class_weight_`;
      return this._py`attr_SVC_class_weight_.tolist() if hasattr(attr_SVC_class_weight_, 'tolist') else attr_SVC_class_weight_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_classes_ = bridgeSVC[${this.id}].classes_`;
      return this._py`attr_SVC_classes_.tolist() if hasattr(attr_SVC_classes_, 'tolist') else attr_SVC_classes_`;
    })();
  }
  /**
    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_dual_coef_ = bridgeSVC[${this.id}].dual_coef_`;
      return this._py`attr_SVC_dual_coef_.tolist() if hasattr(attr_SVC_dual_coef_, 'tolist') else attr_SVC_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_fit_status_ = bridgeSVC[${this.id}].fit_status_`;
      return this._py`attr_SVC_fit_status_.tolist() if hasattr(attr_SVC_fit_status_, 'tolist') else attr_SVC_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_intercept_ = bridgeSVC[${this.id}].intercept_`;
      return this._py`attr_SVC_intercept_.tolist() if hasattr(attr_SVC_intercept_, 'tolist') else attr_SVC_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_n_features_in_ = bridgeSVC[${this.id}].n_features_in_`;
      return this._py`attr_SVC_n_features_in_.tolist() if hasattr(attr_SVC_n_features_in_, 'tolist') else attr_SVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_feature_names_in_ = bridgeSVC[${this.id}].feature_names_in_`;
      return this._py`attr_SVC_feature_names_in_.tolist() if hasattr(attr_SVC_feature_names_in_, 'tolist') else attr_SVC_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_n_iter_ = bridgeSVC[${this.id}].n_iter_`;
      return this._py`attr_SVC_n_iter_.tolist() if hasattr(attr_SVC_n_iter_, 'tolist') else attr_SVC_n_iter_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_support_ = bridgeSVC[${this.id}].support_`;
      return this._py`attr_SVC_support_.tolist() if hasattr(attr_SVC_support_, 'tolist') else attr_SVC_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing support_vectors_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_support_vectors_ = bridgeSVC[${this.id}].support_vectors_`;
      return this._py`attr_SVC_support_vectors_.tolist() if hasattr(attr_SVC_support_vectors_, 'tolist') else attr_SVC_support_vectors_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_shape_fit_ = bridgeSVC[${this.id}].shape_fit_`;
      return this._py`attr_SVC_shape_fit_.tolist() if hasattr(attr_SVC_shape_fit_, 'tolist') else attr_SVC_shape_fit_`;
    })();
  }
};

// src/generated/svm/SVR.ts
import crypto7 from "node:crypto";
var SVR = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SVR${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SVR.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import SVR
try: bridgeSVR
except NameError: bridgeSVR = {}
`;
    await this._py.ex`ctor_SVR = {'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'C': ${this.opts["C"] ?? void 0}, 'epsilon': ${this.opts["epsilon"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_SVR = {k: v for k, v in ctor_SVR.items() if v is not None}`;
    await this._py.ex`bridgeSVR[${this.id}] = SVR(**ctor_SVR)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSVR[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before fit()");
    }
    await this._py.ex`pms_SVR_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVR_fit = {k: v for k, v in pms_SVR_fit.items() if v is not None}`;
    await this._py.ex`res_SVR_fit = bridgeSVR[${this.id}].fit(**pms_SVR_fit)`;
    return this._py`res_SVR_fit.tolist() if hasattr(res_SVR_fit, 'tolist') else res_SVR_fit`;
  }
  /**
      Perform regression on samples in X.
  
      For an one-class model, +1 (inlier) or -1 (outlier) is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before predict()");
    }
    await this._py.ex`pms_SVR_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVR_predict = {k: v for k, v in pms_SVR_predict.items() if v is not None}`;
    await this._py.ex`res_SVR_predict = bridgeSVR[${this.id}].predict(**pms_SVR_predict)`;
    return this._py`res_SVR_predict.tolist() if hasattr(res_SVR_predict, 'tolist') else res_SVR_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y\_true \- y\_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y\_true \- y\_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before score()");
    }
    await this._py.ex`pms_SVR_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVR_score = {k: v for k, v in pms_SVR_score.items() if v is not None}`;
    await this._py.ex`res_SVR_score = bridgeSVR[${this.id}].score(**pms_SVR_score)`;
    return this._py`res_SVR_score.tolist() if hasattr(res_SVR_score, 'tolist') else res_SVR_score`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_class_weight_ = bridgeSVR[${this.id}].class_weight_`;
      return this._py`attr_SVR_class_weight_.tolist() if hasattr(attr_SVR_class_weight_, 'tolist') else attr_SVR_class_weight_`;
    })();
  }
  /**
    Coefficients of the support vector in the decision function.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_dual_coef_ = bridgeSVR[${this.id}].dual_coef_`;
      return this._py`attr_SVR_dual_coef_.tolist() if hasattr(attr_SVR_dual_coef_, 'tolist') else attr_SVR_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_fit_status_ = bridgeSVR[${this.id}].fit_status_`;
      return this._py`attr_SVR_fit_status_.tolist() if hasattr(attr_SVR_fit_status_, 'tolist') else attr_SVR_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_intercept_ = bridgeSVR[${this.id}].intercept_`;
      return this._py`attr_SVR_intercept_.tolist() if hasattr(attr_SVR_intercept_, 'tolist') else attr_SVR_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_n_features_in_ = bridgeSVR[${this.id}].n_features_in_`;
      return this._py`attr_SVR_n_features_in_.tolist() if hasattr(attr_SVR_n_features_in_, 'tolist') else attr_SVR_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_feature_names_in_ = bridgeSVR[${this.id}].feature_names_in_`;
      return this._py`attr_SVR_feature_names_in_.tolist() if hasattr(attr_SVR_feature_names_in_, 'tolist') else attr_SVR_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_n_iter_ = bridgeSVR[${this.id}].n_iter_`;
      return this._py`attr_SVR_n_iter_.tolist() if hasattr(attr_SVR_n_iter_, 'tolist') else attr_SVR_n_iter_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_shape_fit_ = bridgeSVR[${this.id}].shape_fit_`;
      return this._py`attr_SVR_shape_fit_.tolist() if hasattr(attr_SVR_shape_fit_, 'tolist') else attr_SVR_shape_fit_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_support_ = bridgeSVR[${this.id}].support_`;
      return this._py`attr_SVR_support_.tolist() if hasattr(attr_SVR_support_, 'tolist') else attr_SVR_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This SVR instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVR must call init() before accessing support_vectors_");
    }
    return (async () => {
      await this._py.ex`attr_SVR_support_vectors_ = bridgeSVR[${this.id}].support_vectors_`;
      return this._py`attr_SVR_support_vectors_.tolist() if hasattr(attr_SVR_support_vectors_, 'tolist') else attr_SVR_support_vectors_`;
    })();
  }
};
export {
  LinearSVC,
  LinearSVR,
  NuSVC,
  NuSVR,
  OneClassSVM,
  SVC,
  SVR
};
//# sourceMappingURL=index.js.map