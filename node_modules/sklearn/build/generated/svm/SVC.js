// src/generated/svm/SVC.ts
import crypto from "node:crypto";
var SVC = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `SVC${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SVC.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.svm import SVC
try: bridgeSVC
except NameError: bridgeSVC = {}
`;
    await this._py.ex`ctor_SVC = {'C': ${this.opts["C"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'shrinking': ${this.opts["shrinking"] ?? void 0}, 'probability': ${this.opts["probability"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'cache_size': ${this.opts["cache_size"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'decision_function_shape': ${this.opts["decision_function_shape"] ?? void 0}, 'break_ties': ${this.opts["break_ties"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SVC = {k: v for k, v in ctor_SVC.items() if v is not None}`;
    await this._py.ex`bridgeSVC[${this.id}] = SVC(**ctor_SVC)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSVC[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Evaluate the decision function for the samples in X.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before decision_function()");
    }
    await this._py.ex`pms_SVC_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_decision_function = {k: v for k, v in pms_SVC_decision_function.items() if v is not None}`;
    await this._py.ex`res_SVC_decision_function = bridgeSVC[${this.id}].decision_function(**pms_SVC_decision_function)`;
    return this._py`res_SVC_decision_function.tolist() if hasattr(res_SVC_decision_function, 'tolist') else res_SVC_decision_function`;
  }
  /**
    Fit the SVM model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before fit()");
    }
    await this._py.ex`pms_SVC_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVC_fit = {k: v for k, v in pms_SVC_fit.items() if v is not None}`;
    await this._py.ex`res_SVC_fit = bridgeSVC[${this.id}].fit(**pms_SVC_fit)`;
    return this._py`res_SVC_fit.tolist() if hasattr(res_SVC_fit, 'tolist') else res_SVC_fit`;
  }
  /**
      Perform classification on samples in X.
  
      For an one-class model, +1 or -1 is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict()");
    }
    await this._py.ex`pms_SVC_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict = {k: v for k, v in pms_SVC_predict.items() if v is not None}`;
    await this._py.ex`res_SVC_predict = bridgeSVC[${this.id}].predict(**pms_SVC_predict)`;
    return this._py`res_SVC_predict.tolist() if hasattr(res_SVC_predict, 'tolist') else res_SVC_predict`;
  }
  /**
      Compute log probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict_log_proba()");
    }
    await this._py.ex`pms_SVC_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict_log_proba = {k: v for k, v in pms_SVC_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_SVC_predict_log_proba = bridgeSVC[${this.id}].predict_log_proba(**pms_SVC_predict_log_proba)`;
    return this._py`res_SVC_predict_log_proba.tolist() if hasattr(res_SVC_predict_log_proba, 'tolist') else res_SVC_predict_log_proba`;
  }
  /**
      Compute probabilities of possible outcomes for samples in X.
  
      The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before predict_proba()");
    }
    await this._py.ex`pms_SVC_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SVC_predict_proba = {k: v for k, v in pms_SVC_predict_proba.items() if v is not None}`;
    await this._py.ex`res_SVC_predict_proba = bridgeSVC[${this.id}].predict_proba(**pms_SVC_predict_proba)`;
    return this._py`res_SVC_predict_proba.tolist() if hasattr(res_SVC_predict_proba, 'tolist') else res_SVC_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before score()");
    }
    await this._py.ex`pms_SVC_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_SVC_score = {k: v for k, v in pms_SVC_score.items() if v is not None}`;
    await this._py.ex`res_SVC_score = bridgeSVC[${this.id}].score(**pms_SVC_score)`;
    return this._py`res_SVC_score.tolist() if hasattr(res_SVC_score, 'tolist') else res_SVC_score`;
  }
  /**
    Multipliers of parameter C for each class. Computed based on the `class\_weight` parameter.
   */
  get class_weight_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing class_weight_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_class_weight_ = bridgeSVC[${this.id}].class_weight_`;
      return this._py`attr_SVC_class_weight_.tolist() if hasattr(attr_SVC_class_weight_, 'tolist') else attr_SVC_class_weight_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing classes_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_classes_ = bridgeSVC[${this.id}].classes_`;
      return this._py`attr_SVC_classes_.tolist() if hasattr(attr_SVC_classes_, 'tolist') else attr_SVC_classes_`;
    })();
  }
  /**
    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_dual_coef_ = bridgeSVC[${this.id}].dual_coef_`;
      return this._py`attr_SVC_dual_coef_.tolist() if hasattr(attr_SVC_dual_coef_, 'tolist') else attr_SVC_dual_coef_`;
    })();
  }
  /**
    0 if correctly fitted, 1 otherwise (will raise warning)
   */
  get fit_status_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing fit_status_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_fit_status_ = bridgeSVC[${this.id}].fit_status_`;
      return this._py`attr_SVC_fit_status_.tolist() if hasattr(attr_SVC_fit_status_, 'tolist') else attr_SVC_fit_status_`;
    })();
  }
  /**
    Constants in decision function.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_intercept_ = bridgeSVC[${this.id}].intercept_`;
      return this._py`attr_SVC_intercept_.tolist() if hasattr(attr_SVC_intercept_, 'tolist') else attr_SVC_intercept_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_n_features_in_ = bridgeSVC[${this.id}].n_features_in_`;
      return this._py`attr_SVC_n_features_in_.tolist() if hasattr(attr_SVC_n_features_in_, 'tolist') else attr_SVC_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_feature_names_in_ = bridgeSVC[${this.id}].feature_names_in_`;
      return this._py`attr_SVC_feature_names_in_.tolist() if hasattr(attr_SVC_feature_names_in_, 'tolist') else attr_SVC_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_n_iter_ = bridgeSVC[${this.id}].n_iter_`;
      return this._py`attr_SVC_n_iter_.tolist() if hasattr(attr_SVC_n_iter_, 'tolist') else attr_SVC_n_iter_`;
    })();
  }
  /**
    Indices of support vectors.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_support_ = bridgeSVC[${this.id}].support_`;
      return this._py`attr_SVC_support_.tolist() if hasattr(attr_SVC_support_, 'tolist') else attr_SVC_support_`;
    })();
  }
  /**
    Support vectors.
   */
  get support_vectors_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing support_vectors_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_support_vectors_ = bridgeSVC[${this.id}].support_vectors_`;
      return this._py`attr_SVC_support_vectors_.tolist() if hasattr(attr_SVC_support_vectors_, 'tolist') else attr_SVC_support_vectors_`;
    })();
  }
  /**
    Array dimensions of training vector `X`.
   */
  get shape_fit_() {
    if (this._isDisposed) {
      throw new Error("This SVC instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SVC must call init() before accessing shape_fit_");
    }
    return (async () => {
      await this._py.ex`attr_SVC_shape_fit_ = bridgeSVC[${this.id}].shape_fit_`;
      return this._py`attr_SVC_shape_fit_.tolist() if hasattr(attr_SVC_shape_fit_, 'tolist') else attr_SVC_shape_fit_`;
    })();
  }
};
export {
  SVC
};
//# sourceMappingURL=SVC.js.map