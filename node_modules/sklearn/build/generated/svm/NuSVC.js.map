{"version":3,"sources":["../../../src/generated/svm/NuSVC.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Nu-Support Vector Classification.\n\n  Similar to SVC but uses a parameter to control the number of support vectors.\n\n  The implementation is based on libsvm.\n\n  Read more in the [User Guide](../svm.html#svm-classification).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVC.html)\n */\nexport class NuSVC {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      An upper bound on the fraction of margin errors (see [User Guide](../svm.html#nu-svc)) and a lower bound of the fraction of support vectors. Should be in the interval (0, 1\\].\n\n      @defaultValue `0.5`\n     */\n    nu?: number\n\n    /**\n      Specifies the kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'precomputed'\n\n    /**\n      Degree of the polynomial kernel function (‘poly’). Must be non-negative. Ignored by all other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `'scale'`\n     */\n    gamma?: 'scale' | 'auto' | number\n\n    /**\n      Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.\n\n      @defaultValue `0`\n     */\n    coef0?: number\n\n    /**\n      Whether to use the shrinking heuristic. See the [User Guide](../svm.html#shrinking-svm).\n\n      @defaultValue `true`\n     */\n    shrinking?: boolean\n\n    /**\n      Whether to enable probability estimates. This must be enabled prior to calling `fit`, will slow down that method as it internally uses 5-fold cross-validation, and `predict\\_proba` may be inconsistent with `predict`. Read more in the [User Guide](../svm.html#scores-probabilities).\n\n      @defaultValue `false`\n     */\n    probability?: boolean\n\n    /**\n      Tolerance for stopping criterion.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Specify the size of the kernel cache (in MB).\n\n      @defaultValue `200`\n     */\n    cache_size?: number\n\n    /**\n      Set the parameter C of class i to class\\_weight\\[i\\]\\*C for SVC. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies as `n\\_samples / (n\\_classes \\* np.bincount(y))`.\n     */\n    class_weight?: any | 'balanced'\n\n    /**\n      Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      Hard limit on iterations within solver, or -1 for no limit.\n\n      @defaultValue `-1`\n     */\n    max_iter?: number\n\n    /**\n      Whether to return a one-vs-rest (‘ovr’) decision function of shape (n\\_samples, n\\_classes) as all other classifiers, or the original one-vs-one (‘ovo’) decision function of libsvm which has shape (n\\_samples, n\\_classes \\* (n\\_classes - 1) / 2). However, one-vs-one (‘ovo’) is always used as multi-class strategy. The parameter is ignored for binary classification.\n\n      @defaultValue `'ovr'`\n     */\n    decision_function_shape?: 'ovo' | 'ovr'\n\n    /**\n      If true, `decision\\_function\\_shape='ovr'`, and number of classes > 2, [predict](../../glossary.html#term-predict) will break ties according to the confidence values of [decision\\_function](../../glossary.html#term-decision_function); otherwise the first class among the tied classes is returned. Please note that breaking ties comes at a relatively high computational cost compared to a simple predict.\n\n      @defaultValue `false`\n     */\n    break_ties?: boolean\n\n    /**\n      Controls the pseudo random number generation for shuffling the data for probability estimates. Ignored when `probability` is `false`. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `NuSVC${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NuSVC.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.svm import NuSVC\ntry: bridgeNuSVC\nexcept NameError: bridgeNuSVC = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NuSVC = {'nu': ${\n      this.opts['nu'] ?? undefined\n    }, 'kernel': ${this.opts['kernel'] ?? undefined}, 'degree': ${\n      this.opts['degree'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'shrinking': ${this.opts['shrinking'] ?? undefined}, 'probability': ${\n      this.opts['probability'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}, 'cache_size': ${\n      this.opts['cache_size'] ?? undefined\n    }, 'class_weight': ${this.opts['class_weight'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'max_iter': ${\n      this.opts['max_iter'] ?? undefined\n    }, 'decision_function_shape': ${\n      this.opts['decision_function_shape'] ?? undefined\n    }, 'break_ties': ${this.opts['break_ties'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_NuSVC = {k: v for k, v in ctor_NuSVC.items() if v is not None}`\n\n    await this._py.ex`bridgeNuSVC[${this.id}] = NuSVC(**ctor_NuSVC)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNuSVC[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Evaluate the decision function for the samples in X.\n   */\n  async decision_function(opts: {\n    /**\n      The input samples.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_decision_function = {k: v for k, v in pms_NuSVC_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_decision_function = bridgeNuSVC[${this.id}].decision_function(**pms_NuSVC_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_decision_function.tolist() if hasattr(res_NuSVC_decision_function, 'tolist') else res_NuSVC_decision_function`\n  }\n\n  /**\n    Fit the SVM model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vectors, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. For kernel=”precomputed”, the expected shape of X is (n\\_samples, n\\_samples).\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values (class labels in classification, real numbers in regression).\n     */\n    y?: ArrayLike\n\n    /**\n      Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NuSVC_fit = {k: v for k, v in pms_NuSVC_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_fit = bridgeNuSVC[${this.id}].fit(**pms_NuSVC_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_fit.tolist() if hasattr(res_NuSVC_fit, 'tolist') else res_NuSVC_fit`\n  }\n\n  /**\n    Perform classification on samples in X.\n\n    For an one-class model, +1 or -1 is returned.\n   */\n  async predict(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_predict = {k: v for k, v in pms_NuSVC_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_predict = bridgeNuSVC[${this.id}].predict(**pms_NuSVC_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_predict.tolist() if hasattr(res_NuSVC_predict, 'tolist') else res_NuSVC_predict`\n  }\n\n  /**\n    Compute log probabilities of possible outcomes for samples in X.\n\n    The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.\n   */\n  async predict_log_proba(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before predict_log_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_predict_log_proba = {k: v for k, v in pms_NuSVC_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_predict_log_proba = bridgeNuSVC[${this.id}].predict_log_proba(**pms_NuSVC_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_predict_log_proba.tolist() if hasattr(res_NuSVC_predict_log_proba, 'tolist') else res_NuSVC_predict_log_proba`\n  }\n\n  /**\n    Compute probabilities of possible outcomes for samples in X.\n\n    The model need to have probability information computed at training time: fit with attribute `probability` set to `true`.\n   */\n  async predict_proba(opts: {\n    /**\n      For kernel=”precomputed”, the expected shape of X is (n\\_samples\\_test, n\\_samples\\_train).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NuSVC_predict_proba = {k: v for k, v in pms_NuSVC_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_predict_proba = bridgeNuSVC[${this.id}].predict_proba(**pms_NuSVC_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_predict_proba.tolist() if hasattr(res_NuSVC_predict_proba, 'tolist') else res_NuSVC_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NuSVC_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NuSVC_score = {k: v for k, v in pms_NuSVC_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NuSVC_score = bridgeNuSVC[${this.id}].score(**pms_NuSVC_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NuSVC_score.tolist() if hasattr(res_NuSVC_score, 'tolist') else res_NuSVC_score`\n  }\n\n  /**\n    Multipliers of parameter C of each class. Computed based on the `class\\_weight` parameter.\n   */\n  get class_weight_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing class_weight_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_class_weight_ = bridgeNuSVC[${this.id}].class_weight_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_class_weight_.tolist() if hasattr(attr_NuSVC_class_weight_, 'tolist') else attr_NuSVC_class_weight_`\n    })()\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing classes_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVC_classes_ = bridgeNuSVC[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_classes_.tolist() if hasattr(attr_NuSVC_classes_, 'tolist') else attr_NuSVC_classes_`\n    })()\n  }\n\n  /**\n    Dual coefficients of the support vector in the decision function (see [Mathematical formulation](../sgd.html#sgd-mathematical-formulation)), multiplied by their targets. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial. See the [multi-class section of the User Guide](../svm.html#svm-multi-class) for details.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_dual_coef_ = bridgeNuSVC[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_dual_coef_.tolist() if hasattr(attr_NuSVC_dual_coef_, 'tolist') else attr_NuSVC_dual_coef_`\n    })()\n  }\n\n  /**\n    0 if correctly fitted, 1 if the algorithm did not converge.\n   */\n  get fit_status_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing fit_status_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_fit_status_ = bridgeNuSVC[${this.id}].fit_status_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_fit_status_.tolist() if hasattr(attr_NuSVC_fit_status_, 'tolist') else attr_NuSVC_fit_status_`\n    })()\n  }\n\n  /**\n    Constants in decision function.\n   */\n  get intercept_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing intercept_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_intercept_ = bridgeNuSVC[${this.id}].intercept_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_intercept_.tolist() if hasattr(attr_NuSVC_intercept_, 'tolist') else attr_NuSVC_intercept_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_n_features_in_ = bridgeNuSVC[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_n_features_in_.tolist() if hasattr(attr_NuSVC_n_features_in_, 'tolist') else attr_NuSVC_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NuSVC must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_feature_names_in_ = bridgeNuSVC[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_feature_names_in_.tolist() if hasattr(attr_NuSVC_feature_names_in_, 'tolist') else attr_NuSVC_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run by the optimization routine to fit the model. The shape of this attribute depends on the number of models optimized which in turn depends on the number of classes.\n   */\n  get n_iter_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVC_n_iter_ = bridgeNuSVC[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_n_iter_.tolist() if hasattr(attr_NuSVC_n_iter_, 'tolist') else attr_NuSVC_n_iter_`\n    })()\n  }\n\n  /**\n    Indices of support vectors.\n   */\n  get support_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing support_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_NuSVC_support_ = bridgeNuSVC[${this.id}].support_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_support_.tolist() if hasattr(attr_NuSVC_support_, 'tolist') else attr_NuSVC_support_`\n    })()\n  }\n\n  /**\n    Support vectors.\n   */\n  get support_vectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NuSVC must call init() before accessing support_vectors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_support_vectors_ = bridgeNuSVC[${this.id}].support_vectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_support_vectors_.tolist() if hasattr(attr_NuSVC_support_vectors_, 'tolist') else attr_NuSVC_support_vectors_`\n    })()\n  }\n\n  /**\n    Array dimensions of training vector `X`.\n   */\n  get shape_fit_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This NuSVC instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NuSVC must call init() before accessing shape_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NuSVC_shape_fit_ = bridgeNuSVC[${this.id}].shape_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NuSVC_shape_fit_.tolist() if hasattr(attr_NuSVC_shape_fit_, 'tolist') else attr_NuSVC_shape_fit_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}