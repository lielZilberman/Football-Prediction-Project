{"version":3,"sources":["../../../src/generated/model_selection/ParameterSampler.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Generator on parameters sampled from given distributions.\n\n  Non-deterministic iterable over random candidate combinations for hyper- parameter search. If all parameters are presented as a list, sampling without replacement is performed. If at least one parameter is given as a distribution, sampling with replacement is used. It is highly recommended to use continuous distributions for continuous parameters.\n\n  Read more in the [User Guide](../grid_search.html#grid-search).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.ParameterSampler.html)\n */\nexport class ParameterSampler {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Dictionary with parameters names (`str`) as keys and distributions or lists of parameters to try. Distributions must provide a `rvs` method for sampling (such as those from scipy.stats.distributions). If a list is given, it is sampled uniformly. If a list of dicts is given, first a dict is sampled uniformly, and then a parameter is sampled using that dict as above.\n     */\n    param_distributions?: any\n\n    /**\n      Number of parameter settings that are produced.\n     */\n    n_iter?: number\n\n    /**\n      Pseudo random number generator state used for random uniform sampling from lists of possible values instead of scipy.stats distributions. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n  }) {\n    this.id = `ParameterSampler${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ParameterSampler instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('ParameterSampler.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.model_selection import ParameterSampler\ntry: bridgeParameterSampler\nexcept NameError: bridgeParameterSampler = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_ParameterSampler = {'param_distributions': ${\n      this.opts['param_distributions'] ?? undefined\n    }, 'n_iter': ${this.opts['n_iter'] ?? undefined}, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }}\n\nctor_ParameterSampler = {k: v for k, v in ctor_ParameterSampler.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeParameterSampler[${this.id}] = ParameterSampler(**ctor_ParameterSampler)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeParameterSampler[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n   **Yields** dictionaries mapping each estimator parameter to as sampled value.\n   */\n  get params(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ParameterSampler instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ParameterSampler must call init() before accessing params'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ParameterSampler_params = bridgeParameterSampler[${this.id}].params`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ParameterSampler_params.tolist() if hasattr(attr_ParameterSampler_params, 'tolist') else attr_ParameterSampler_params`\n    })()\n  }\n}\n"],"mappings":";AAGA,OAAO,YAAY;AAaZ,IAAM,mBAAN,MAAuB;AAAA,EAQ5B,YAAY,MAeT;AAlBH,0BAA0B;AAC1B,uBAAuB;AAkBrB,SAAK,KAAK,mBAAmB,OAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAC7D,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,qDACb,KAAK,KAAK,qBAAqB,KAAK,qBACvB,KAAK,KAAK,QAAQ,KAAK,2BACpC,KAAK,KAAK,cAAc,KAAK;AAAA;AAAA;AAK/B,UAAM,KAAK,IACR,4BAA4B,KAAK;AAEpC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,gCAAgC,KAAK;AAEpD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAuB;AACzB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,2DAA2D,KAAK;AAGnE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;","names":[]}