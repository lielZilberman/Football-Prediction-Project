// src/generated/mixture/BayesianGaussianMixture.ts
import crypto from "node:crypto";
var BayesianGaussianMixture = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `BayesianGaussianMixture${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "BayesianGaussianMixture.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.mixture import BayesianGaussianMixture
try: bridgeBayesianGaussianMixture
except NameError: bridgeBayesianGaussianMixture = {}
`;
    await this._py.ex`ctor_BayesianGaussianMixture = {'n_components': ${this.opts["n_components"] ?? void 0}, 'covariance_type': ${this.opts["covariance_type"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'reg_covar': ${this.opts["reg_covar"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'init_params': ${this.opts["init_params"] ?? void 0}, 'weight_concentration_prior_type': ${this.opts["weight_concentration_prior_type"] ?? void 0}, 'weight_concentration_prior': ${this.opts["weight_concentration_prior"] ?? void 0}, 'mean_precision_prior': ${this.opts["mean_precision_prior"] ?? void 0}, 'mean_prior': ${this.opts["mean_prior"] ?? void 0}, 'degrees_of_freedom_prior': ${this.opts["degrees_of_freedom_prior"] ?? void 0}, 'covariance_prior': ${this.opts["covariance_prior"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'verbose_interval': ${this.opts["verbose_interval"] ?? void 0}}

ctor_BayesianGaussianMixture = {k: v for k, v in ctor_BayesianGaussianMixture.items() if v is not None}`;
    await this._py.ex`bridgeBayesianGaussianMixture[${this.id}] = BayesianGaussianMixture(**ctor_BayesianGaussianMixture)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBayesianGaussianMixture[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Estimate model parameters with the EM algorithm.
  
      The method fits the model `n\_init` times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a `ConvergenceWarning` is raised. If `warm\_start` is `true`, then `n\_init` is ignored and a single initialization is performed upon the first call. Upon consecutive calls, training starts where it left off.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BayesianGaussianMixture must call init() before fit()");
    }
    await this._py.ex`pms_BayesianGaussianMixture_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_BayesianGaussianMixture_fit = {k: v for k, v in pms_BayesianGaussianMixture_fit.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_fit = bridgeBayesianGaussianMixture[${this.id}].fit(**pms_BayesianGaussianMixture_fit)`;
    return this._py`res_BayesianGaussianMixture_fit.tolist() if hasattr(res_BayesianGaussianMixture_fit, 'tolist') else res_BayesianGaussianMixture_fit`;
  }
  /**
      Estimate model parameters using X and predict the labels for X.
  
      The method fits the model n\_init times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a [`ConvergenceWarning`](sklearn.exceptions.ConvergenceWarning.html#sklearn.exceptions.ConvergenceWarning "sklearn.exceptions.ConvergenceWarning") is raised. After fitting, it predicts the most probable label for the input data points.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_BayesianGaussianMixture_fit_predict = {k: v for k, v in pms_BayesianGaussianMixture_fit_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_fit_predict = bridgeBayesianGaussianMixture[${this.id}].fit_predict(**pms_BayesianGaussianMixture_fit_predict)`;
    return this._py`res_BayesianGaussianMixture_fit_predict.tolist() if hasattr(res_BayesianGaussianMixture_fit_predict, 'tolist') else res_BayesianGaussianMixture_fit_predict`;
  }
  /**
    Predict the labels for the data samples in X using trained model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before predict()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BayesianGaussianMixture_predict = {k: v for k, v in pms_BayesianGaussianMixture_predict.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_predict = bridgeBayesianGaussianMixture[${this.id}].predict(**pms_BayesianGaussianMixture_predict)`;
    return this._py`res_BayesianGaussianMixture_predict.tolist() if hasattr(res_BayesianGaussianMixture_predict, 'tolist') else res_BayesianGaussianMixture_predict`;
  }
  /**
    Evaluate the componentsâ€™ density for each sample.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BayesianGaussianMixture_predict_proba = {k: v for k, v in pms_BayesianGaussianMixture_predict_proba.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_predict_proba = bridgeBayesianGaussianMixture[${this.id}].predict_proba(**pms_BayesianGaussianMixture_predict_proba)`;
    return this._py`res_BayesianGaussianMixture_predict_proba.tolist() if hasattr(res_BayesianGaussianMixture_predict_proba, 'tolist') else res_BayesianGaussianMixture_predict_proba`;
  }
  /**
    Generate random samples from the fitted Gaussian distribution.
   */
  async sample(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before sample()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_sample = {'n_samples': ${opts["n_samples"] ?? void 0}}

pms_BayesianGaussianMixture_sample = {k: v for k, v in pms_BayesianGaussianMixture_sample.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_sample = bridgeBayesianGaussianMixture[${this.id}].sample(**pms_BayesianGaussianMixture_sample)`;
    return this._py`res_BayesianGaussianMixture_sample.tolist() if hasattr(res_BayesianGaussianMixture_sample, 'tolist') else res_BayesianGaussianMixture_sample`;
  }
  /**
    Compute the per-sample average log-likelihood of the given data X.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BayesianGaussianMixture must call init() before score()");
    }
    await this._py.ex`pms_BayesianGaussianMixture_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_BayesianGaussianMixture_score = {k: v for k, v in pms_BayesianGaussianMixture_score.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_score = bridgeBayesianGaussianMixture[${this.id}].score(**pms_BayesianGaussianMixture_score)`;
    return this._py`res_BayesianGaussianMixture_score.tolist() if hasattr(res_BayesianGaussianMixture_score, 'tolist') else res_BayesianGaussianMixture_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_BayesianGaussianMixture_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BayesianGaussianMixture_score_samples = {k: v for k, v in pms_BayesianGaussianMixture_score_samples.items() if v is not None}`;
    await this._py.ex`res_BayesianGaussianMixture_score_samples = bridgeBayesianGaussianMixture[${this.id}].score_samples(**pms_BayesianGaussianMixture_score_samples)`;
    return this._py`res_BayesianGaussianMixture_score_samples.tolist() if hasattr(res_BayesianGaussianMixture_score_samples, 'tolist') else res_BayesianGaussianMixture_score_samples`;
  }
  /**
    The weights of each mixture components.
   */
  get weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_weights_ = bridgeBayesianGaussianMixture[${this.id}].weights_`;
      return this._py`attr_BayesianGaussianMixture_weights_.tolist() if hasattr(attr_BayesianGaussianMixture_weights_, 'tolist') else attr_BayesianGaussianMixture_weights_`;
    })();
  }
  /**
    The mean of each mixture component.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_means_ = bridgeBayesianGaussianMixture[${this.id}].means_`;
      return this._py`attr_BayesianGaussianMixture_means_.tolist() if hasattr(attr_BayesianGaussianMixture_means_, 'tolist') else attr_BayesianGaussianMixture_means_`;
    })();
  }
  /**
    The covariance of each mixture component. The shape depends on `covariance\_type`:
   */
  get covariances_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing covariances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_covariances_ = bridgeBayesianGaussianMixture[${this.id}].covariances_`;
      return this._py`attr_BayesianGaussianMixture_covariances_.tolist() if hasattr(attr_BayesianGaussianMixture_covariances_, 'tolist') else attr_BayesianGaussianMixture_covariances_`;
    })();
  }
  /**
    The precision matrices for each component in the mixture. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing precisions_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_precisions_ = bridgeBayesianGaussianMixture[${this.id}].precisions_`;
      return this._py`attr_BayesianGaussianMixture_precisions_.tolist() if hasattr(attr_BayesianGaussianMixture_precisions_, 'tolist') else attr_BayesianGaussianMixture_precisions_`;
    })();
  }
  /**
    The cholesky decomposition of the precision matrices of each mixture component. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_cholesky_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing precisions_cholesky_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_precisions_cholesky_ = bridgeBayesianGaussianMixture[${this.id}].precisions_cholesky_`;
      return this._py`attr_BayesianGaussianMixture_precisions_cholesky_.tolist() if hasattr(attr_BayesianGaussianMixture_precisions_cholesky_, 'tolist') else attr_BayesianGaussianMixture_precisions_cholesky_`;
    })();
  }
  /**
    True when convergence was reached in fit(), `false` otherwise.
   */
  get converged_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing converged_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_converged_ = bridgeBayesianGaussianMixture[${this.id}].converged_`;
      return this._py`attr_BayesianGaussianMixture_converged_.tolist() if hasattr(attr_BayesianGaussianMixture_converged_, 'tolist') else attr_BayesianGaussianMixture_converged_`;
    })();
  }
  /**
    Number of step used by the best fit of inference to reach the convergence.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_n_iter_ = bridgeBayesianGaussianMixture[${this.id}].n_iter_`;
      return this._py`attr_BayesianGaussianMixture_n_iter_.tolist() if hasattr(attr_BayesianGaussianMixture_n_iter_, 'tolist') else attr_BayesianGaussianMixture_n_iter_`;
    })();
  }
  /**
    Lower bound value on the model evidence (of the training data) of the best fit of inference.
   */
  get lower_bound_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing lower_bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_lower_bound_ = bridgeBayesianGaussianMixture[${this.id}].lower_bound_`;
      return this._py`attr_BayesianGaussianMixture_lower_bound_.tolist() if hasattr(attr_BayesianGaussianMixture_lower_bound_, 'tolist') else attr_BayesianGaussianMixture_lower_bound_`;
    })();
  }
  /**
    The dirichlet concentration of each component on the weight distribution (Dirichlet). The type depends on `weight\_concentration\_prior\_type`:
   */
  get weight_concentration_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing weight_concentration_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_weight_concentration_prior_ = bridgeBayesianGaussianMixture[${this.id}].weight_concentration_prior_`;
      return this._py`attr_BayesianGaussianMixture_weight_concentration_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_weight_concentration_prior_, 'tolist') else attr_BayesianGaussianMixture_weight_concentration_prior_`;
    })();
  }
  /**
    The dirichlet concentration of each component on the weight distribution (Dirichlet).
   */
  get weight_concentration_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing weight_concentration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_weight_concentration_ = bridgeBayesianGaussianMixture[${this.id}].weight_concentration_`;
      return this._py`attr_BayesianGaussianMixture_weight_concentration_.tolist() if hasattr(attr_BayesianGaussianMixture_weight_concentration_, 'tolist') else attr_BayesianGaussianMixture_weight_concentration_`;
    })();
  }
  /**
    The precision prior on the mean distribution (Gaussian). Controls the extent of where means can be placed. Larger values concentrate the cluster means around `mean\_prior`. If mean\_precision\_prior is set to `undefined`, `mean\_precision\_prior\_` is set to 1.
   */
  get mean_precision_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing mean_precision_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_mean_precision_prior_ = bridgeBayesianGaussianMixture[${this.id}].mean_precision_prior_`;
      return this._py`attr_BayesianGaussianMixture_mean_precision_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_mean_precision_prior_, 'tolist') else attr_BayesianGaussianMixture_mean_precision_prior_`;
    })();
  }
  /**
    The precision of each components on the mean distribution (Gaussian).
   */
  get mean_precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing mean_precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_mean_precision_ = bridgeBayesianGaussianMixture[${this.id}].mean_precision_`;
      return this._py`attr_BayesianGaussianMixture_mean_precision_.tolist() if hasattr(attr_BayesianGaussianMixture_mean_precision_, 'tolist') else attr_BayesianGaussianMixture_mean_precision_`;
    })();
  }
  /**
    The prior on the mean distribution (Gaussian).
   */
  get mean_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing mean_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_mean_prior_ = bridgeBayesianGaussianMixture[${this.id}].mean_prior_`;
      return this._py`attr_BayesianGaussianMixture_mean_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_mean_prior_, 'tolist') else attr_BayesianGaussianMixture_mean_prior_`;
    })();
  }
  /**
    The prior of the number of degrees of freedom on the covariance distributions (Wishart).
   */
  get degrees_of_freedom_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing degrees_of_freedom_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_degrees_of_freedom_prior_ = bridgeBayesianGaussianMixture[${this.id}].degrees_of_freedom_prior_`;
      return this._py`attr_BayesianGaussianMixture_degrees_of_freedom_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_degrees_of_freedom_prior_, 'tolist') else attr_BayesianGaussianMixture_degrees_of_freedom_prior_`;
    })();
  }
  /**
    The number of degrees of freedom of each components in the model.
   */
  get degrees_of_freedom_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing degrees_of_freedom_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_degrees_of_freedom_ = bridgeBayesianGaussianMixture[${this.id}].degrees_of_freedom_`;
      return this._py`attr_BayesianGaussianMixture_degrees_of_freedom_.tolist() if hasattr(attr_BayesianGaussianMixture_degrees_of_freedom_, 'tolist') else attr_BayesianGaussianMixture_degrees_of_freedom_`;
    })();
  }
  /**
    The prior on the covariance distribution (Wishart). The shape depends on `covariance\_type`:
   */
  get covariance_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing covariance_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_covariance_prior_ = bridgeBayesianGaussianMixture[${this.id}].covariance_prior_`;
      return this._py`attr_BayesianGaussianMixture_covariance_prior_.tolist() if hasattr(attr_BayesianGaussianMixture_covariance_prior_, 'tolist') else attr_BayesianGaussianMixture_covariance_prior_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_n_features_in_ = bridgeBayesianGaussianMixture[${this.id}].n_features_in_`;
      return this._py`attr_BayesianGaussianMixture_n_features_in_.tolist() if hasattr(attr_BayesianGaussianMixture_n_features_in_, 'tolist') else attr_BayesianGaussianMixture_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BayesianGaussianMixture instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BayesianGaussianMixture must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BayesianGaussianMixture_feature_names_in_ = bridgeBayesianGaussianMixture[${this.id}].feature_names_in_`;
      return this._py`attr_BayesianGaussianMixture_feature_names_in_.tolist() if hasattr(attr_BayesianGaussianMixture_feature_names_in_, 'tolist') else attr_BayesianGaussianMixture_feature_names_in_`;
    })();
  }
};

// src/generated/mixture/GaussianMixture.ts
import crypto2 from "node:crypto";
var GaussianMixture = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `GaussianMixture${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GaussianMixture.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.mixture import GaussianMixture
try: bridgeGaussianMixture
except NameError: bridgeGaussianMixture = {}
`;
    await this._py.ex`ctor_GaussianMixture = {'n_components': ${this.opts["n_components"] ?? void 0}, 'covariance_type': ${this.opts["covariance_type"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'reg_covar': ${this.opts["reg_covar"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'init_params': ${this.opts["init_params"] ?? void 0}, 'weights_init': np.array(${this.opts["weights_init"] ?? void 0}) if ${this.opts["weights_init"] !== void 0} else None, 'means_init': np.array(${this.opts["means_init"] ?? void 0}) if ${this.opts["means_init"] !== void 0} else None, 'precisions_init': ${this.opts["precisions_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'verbose_interval': ${this.opts["verbose_interval"] ?? void 0}}

ctor_GaussianMixture = {k: v for k, v in ctor_GaussianMixture.items() if v is not None}`;
    await this._py.ex`bridgeGaussianMixture[${this.id}] = GaussianMixture(**ctor_GaussianMixture)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGaussianMixture[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Akaike information criterion for the current model on the input X.
  
      You can refer to this [mathematical section](../linear_model.html#aic-bic) for more details regarding the formulation of the AIC used.
     */
  async aic(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before aic()");
    }
    await this._py.ex`pms_GaussianMixture_aic = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_aic = {k: v for k, v in pms_GaussianMixture_aic.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_aic = bridgeGaussianMixture[${this.id}].aic(**pms_GaussianMixture_aic)`;
    return this._py`res_GaussianMixture_aic.tolist() if hasattr(res_GaussianMixture_aic, 'tolist') else res_GaussianMixture_aic`;
  }
  /**
      Bayesian information criterion for the current model on the input X.
  
      You can refer to this [mathematical section](../linear_model.html#aic-bic) for more details regarding the formulation of the BIC used.
     */
  async bic(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before bic()");
    }
    await this._py.ex`pms_GaussianMixture_bic = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_bic = {k: v for k, v in pms_GaussianMixture_bic.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_bic = bridgeGaussianMixture[${this.id}].bic(**pms_GaussianMixture_bic)`;
    return this._py`res_GaussianMixture_bic.tolist() if hasattr(res_GaussianMixture_bic, 'tolist') else res_GaussianMixture_bic`;
  }
  /**
      Estimate model parameters with the EM algorithm.
  
      The method fits the model `n\_init` times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a `ConvergenceWarning` is raised. If `warm\_start` is `true`, then `n\_init` is ignored and a single initialization is performed upon the first call. Upon consecutive calls, training starts where it left off.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before fit()");
    }
    await this._py.ex`pms_GaussianMixture_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianMixture_fit = {k: v for k, v in pms_GaussianMixture_fit.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_fit = bridgeGaussianMixture[${this.id}].fit(**pms_GaussianMixture_fit)`;
    return this._py`res_GaussianMixture_fit.tolist() if hasattr(res_GaussianMixture_fit, 'tolist') else res_GaussianMixture_fit`;
  }
  /**
      Estimate model parameters using X and predict the labels for X.
  
      The method fits the model n\_init times and sets the parameters with which the model has the largest likelihood or lower bound. Within each trial, the method iterates between E-step and M-step for `max\_iter` times until the change of likelihood or lower bound is less than `tol`, otherwise, a [`ConvergenceWarning`](sklearn.exceptions.ConvergenceWarning.html#sklearn.exceptions.ConvergenceWarning "sklearn.exceptions.ConvergenceWarning") is raised. After fitting, it predicts the most probable label for the input data points.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before fit_predict()");
    }
    await this._py.ex`pms_GaussianMixture_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianMixture_fit_predict = {k: v for k, v in pms_GaussianMixture_fit_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_fit_predict = bridgeGaussianMixture[${this.id}].fit_predict(**pms_GaussianMixture_fit_predict)`;
    return this._py`res_GaussianMixture_fit_predict.tolist() if hasattr(res_GaussianMixture_fit_predict, 'tolist') else res_GaussianMixture_fit_predict`;
  }
  /**
    Predict the labels for the data samples in X using trained model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before predict()");
    }
    await this._py.ex`pms_GaussianMixture_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_predict = {k: v for k, v in pms_GaussianMixture_predict.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_predict = bridgeGaussianMixture[${this.id}].predict(**pms_GaussianMixture_predict)`;
    return this._py`res_GaussianMixture_predict.tolist() if hasattr(res_GaussianMixture_predict, 'tolist') else res_GaussianMixture_predict`;
  }
  /**
    Evaluate the componentsâ€™ density for each sample.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before predict_proba()");
    }
    await this._py.ex`pms_GaussianMixture_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_predict_proba = {k: v for k, v in pms_GaussianMixture_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_predict_proba = bridgeGaussianMixture[${this.id}].predict_proba(**pms_GaussianMixture_predict_proba)`;
    return this._py`res_GaussianMixture_predict_proba.tolist() if hasattr(res_GaussianMixture_predict_proba, 'tolist') else res_GaussianMixture_predict_proba`;
  }
  /**
    Generate random samples from the fitted Gaussian distribution.
   */
  async sample(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before sample()");
    }
    await this._py.ex`pms_GaussianMixture_sample = {'n_samples': ${opts["n_samples"] ?? void 0}}

pms_GaussianMixture_sample = {k: v for k, v in pms_GaussianMixture_sample.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_sample = bridgeGaussianMixture[${this.id}].sample(**pms_GaussianMixture_sample)`;
    return this._py`res_GaussianMixture_sample.tolist() if hasattr(res_GaussianMixture_sample, 'tolist') else res_GaussianMixture_sample`;
  }
  /**
    Compute the per-sample average log-likelihood of the given data X.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before score()");
    }
    await this._py.ex`pms_GaussianMixture_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GaussianMixture_score = {k: v for k, v in pms_GaussianMixture_score.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_score = bridgeGaussianMixture[${this.id}].score(**pms_GaussianMixture_score)`;
    return this._py`res_GaussianMixture_score.tolist() if hasattr(res_GaussianMixture_score, 'tolist') else res_GaussianMixture_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GaussianMixture must call init() before score_samples()");
    }
    await this._py.ex`pms_GaussianMixture_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GaussianMixture_score_samples = {k: v for k, v in pms_GaussianMixture_score_samples.items() if v is not None}`;
    await this._py.ex`res_GaussianMixture_score_samples = bridgeGaussianMixture[${this.id}].score_samples(**pms_GaussianMixture_score_samples)`;
    return this._py`res_GaussianMixture_score_samples.tolist() if hasattr(res_GaussianMixture_score_samples, 'tolist') else res_GaussianMixture_score_samples`;
  }
  /**
    The weights of each mixture components.
   */
  get weights_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_weights_ = bridgeGaussianMixture[${this.id}].weights_`;
      return this._py`attr_GaussianMixture_weights_.tolist() if hasattr(attr_GaussianMixture_weights_, 'tolist') else attr_GaussianMixture_weights_`;
    })();
  }
  /**
    The mean of each mixture component.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_means_ = bridgeGaussianMixture[${this.id}].means_`;
      return this._py`attr_GaussianMixture_means_.tolist() if hasattr(attr_GaussianMixture_means_, 'tolist') else attr_GaussianMixture_means_`;
    })();
  }
  /**
    The covariance of each mixture component. The shape depends on `covariance\_type`:
   */
  get covariances_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing covariances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_covariances_ = bridgeGaussianMixture[${this.id}].covariances_`;
      return this._py`attr_GaussianMixture_covariances_.tolist() if hasattr(attr_GaussianMixture_covariances_, 'tolist') else attr_GaussianMixture_covariances_`;
    })();
  }
  /**
    The precision matrices for each component in the mixture. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing precisions_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_precisions_ = bridgeGaussianMixture[${this.id}].precisions_`;
      return this._py`attr_GaussianMixture_precisions_.tolist() if hasattr(attr_GaussianMixture_precisions_, 'tolist') else attr_GaussianMixture_precisions_`;
    })();
  }
  /**
    The cholesky decomposition of the precision matrices of each mixture component. A precision matrix is the inverse of a covariance matrix. A covariance matrix is symmetric positive definite so the mixture of Gaussian can be equivalently parameterized by the precision matrices. Storing the precision matrices instead of the covariance matrices makes it more efficient to compute the log-likelihood of new samples at test time. The shape depends on `covariance\_type`:
   */
  get precisions_cholesky_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing precisions_cholesky_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_precisions_cholesky_ = bridgeGaussianMixture[${this.id}].precisions_cholesky_`;
      return this._py`attr_GaussianMixture_precisions_cholesky_.tolist() if hasattr(attr_GaussianMixture_precisions_cholesky_, 'tolist') else attr_GaussianMixture_precisions_cholesky_`;
    })();
  }
  /**
    True when convergence was reached in fit(), `false` otherwise.
   */
  get converged_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing converged_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_converged_ = bridgeGaussianMixture[${this.id}].converged_`;
      return this._py`attr_GaussianMixture_converged_.tolist() if hasattr(attr_GaussianMixture_converged_, 'tolist') else attr_GaussianMixture_converged_`;
    })();
  }
  /**
    Number of step used by the best fit of EM to reach the convergence.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_n_iter_ = bridgeGaussianMixture[${this.id}].n_iter_`;
      return this._py`attr_GaussianMixture_n_iter_.tolist() if hasattr(attr_GaussianMixture_n_iter_, 'tolist') else attr_GaussianMixture_n_iter_`;
    })();
  }
  /**
    Lower bound value on the log-likelihood (of the training data with respect to the model) of the best fit of EM.
   */
  get lower_bound_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing lower_bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_lower_bound_ = bridgeGaussianMixture[${this.id}].lower_bound_`;
      return this._py`attr_GaussianMixture_lower_bound_.tolist() if hasattr(attr_GaussianMixture_lower_bound_, 'tolist') else attr_GaussianMixture_lower_bound_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_n_features_in_ = bridgeGaussianMixture[${this.id}].n_features_in_`;
      return this._py`attr_GaussianMixture_n_features_in_.tolist() if hasattr(attr_GaussianMixture_n_features_in_, 'tolist') else attr_GaussianMixture_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GaussianMixture instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GaussianMixture must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GaussianMixture_feature_names_in_ = bridgeGaussianMixture[${this.id}].feature_names_in_`;
      return this._py`attr_GaussianMixture_feature_names_in_.tolist() if hasattr(attr_GaussianMixture_feature_names_in_, 'tolist') else attr_GaussianMixture_feature_names_in_`;
    })();
  }
};
export {
  BayesianGaussianMixture,
  GaussianMixture
};
//# sourceMappingURL=index.js.map