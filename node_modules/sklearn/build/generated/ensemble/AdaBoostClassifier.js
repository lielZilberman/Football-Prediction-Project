// src/generated/ensemble/AdaBoostClassifier.ts
import crypto from "node:crypto";
var AdaBoostClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `AdaBoostClassifier${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AdaBoostClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import AdaBoostClassifier
try: bridgeAdaBoostClassifier
except NameError: bridgeAdaBoostClassifier = {}
`;
    await this._py.ex`ctor_AdaBoostClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'base_estimator': ${this.opts["base_estimator"] ?? void 0}}

ctor_AdaBoostClassifier = {k: v for k, v in ctor_AdaBoostClassifier.items() if v is not None}`;
    await this._py.ex`bridgeAdaBoostClassifier[${this.id}] = AdaBoostClassifier(**ctor_AdaBoostClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAdaBoostClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_decision_function = {k: v for k, v in pms_AdaBoostClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_decision_function = bridgeAdaBoostClassifier[${this.id}].decision_function(**pms_AdaBoostClassifier_decision_function)`;
    return this._py`res_AdaBoostClassifier_decision_function.tolist() if hasattr(res_AdaBoostClassifier_decision_function, 'tolist') else res_AdaBoostClassifier_decision_function`;
  }
  /**
    Build a boosted classifier/regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before fit()");
    }
    await this._py.ex`pms_AdaBoostClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_fit = {k: v for k, v in pms_AdaBoostClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_fit = bridgeAdaBoostClassifier[${this.id}].fit(**pms_AdaBoostClassifier_fit)`;
    return this._py`res_AdaBoostClassifier_fit.tolist() if hasattr(res_AdaBoostClassifier_fit, 'tolist') else res_AdaBoostClassifier_fit`;
  }
  /**
      Predict classes for X.
  
      The predicted class of an input sample is computed as the weighted mean prediction of the classifiers in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before predict()");
    }
    await this._py.ex`pms_AdaBoostClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict = {k: v for k, v in pms_AdaBoostClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict = bridgeAdaBoostClassifier[${this.id}].predict(**pms_AdaBoostClassifier_predict)`;
    return this._py`res_AdaBoostClassifier_predict.tolist() if hasattr(res_AdaBoostClassifier_predict, 'tolist') else res_AdaBoostClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the weighted mean predicted class log-probabilities of the classifiers in the ensemble.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict_log_proba = {k: v for k, v in pms_AdaBoostClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict_log_proba = bridgeAdaBoostClassifier[${this.id}].predict_log_proba(**pms_AdaBoostClassifier_predict_log_proba)`;
    return this._py`res_AdaBoostClassifier_predict_log_proba.tolist() if hasattr(res_AdaBoostClassifier_predict_log_proba, 'tolist') else res_AdaBoostClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the weighted mean predicted class probabilities of the classifiers in the ensemble.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict_proba = {k: v for k, v in pms_AdaBoostClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict_proba = bridgeAdaBoostClassifier[${this.id}].predict_proba(**pms_AdaBoostClassifier_predict_proba)`;
    return this._py`res_AdaBoostClassifier_predict_proba.tolist() if hasattr(res_AdaBoostClassifier_predict_proba, 'tolist') else res_AdaBoostClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before score()");
    }
    await this._py.ex`pms_AdaBoostClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_score = {k: v for k, v in pms_AdaBoostClassifier_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_score = bridgeAdaBoostClassifier[${this.id}].score(**pms_AdaBoostClassifier_score)`;
    return this._py`res_AdaBoostClassifier_score.tolist() if hasattr(res_AdaBoostClassifier_score, 'tolist') else res_AdaBoostClassifier_score`;
  }
  /**
      Compute decision function of `X` for each boosting iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each boosting iteration.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_decision_function = {k: v for k, v in pms_AdaBoostClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_decision_function = bridgeAdaBoostClassifier[${this.id}].staged_decision_function(**pms_AdaBoostClassifier_staged_decision_function)`;
    return this._py`res_AdaBoostClassifier_staged_decision_function.tolist() if hasattr(res_AdaBoostClassifier_staged_decision_function, 'tolist') else res_AdaBoostClassifier_staged_decision_function`;
  }
  /**
      Return staged predictions for X.
  
      The predicted class of an input sample is computed as the weighted mean prediction of the classifiers in the ensemble.
  
      This generator method yields the ensemble prediction after each iteration of boosting and therefore allows monitoring, such as to determine the prediction on a test set after each boost.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_predict = {k: v for k, v in pms_AdaBoostClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_predict = bridgeAdaBoostClassifier[${this.id}].staged_predict(**pms_AdaBoostClassifier_staged_predict)`;
    return this._py`res_AdaBoostClassifier_staged_predict.tolist() if hasattr(res_AdaBoostClassifier_staged_predict, 'tolist') else res_AdaBoostClassifier_staged_predict`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the weighted mean predicted class probabilities of the classifiers in the ensemble.
  
      This generator method yields the ensemble predicted class probabilities after each iteration of boosting and therefore allows monitoring, such as to determine the predicted class probabilities on a test set after each boost.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_predict_proba = {k: v for k, v in pms_AdaBoostClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_predict_proba = bridgeAdaBoostClassifier[${this.id}].staged_predict_proba(**pms_AdaBoostClassifier_staged_predict_proba)`;
    return this._py`res_AdaBoostClassifier_staged_predict_proba.tolist() if hasattr(res_AdaBoostClassifier_staged_predict_proba, 'tolist') else res_AdaBoostClassifier_staged_predict_proba`;
  }
  /**
      Return staged scores for X, y.
  
      This generator method yields the ensemble score after each iteration of boosting and therefore allows monitoring, such as to determine the score on a test set after each boost.
     */
  async staged_score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_score()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_staged_score = {k: v for k, v in pms_AdaBoostClassifier_staged_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_score = bridgeAdaBoostClassifier[${this.id}].staged_score(**pms_AdaBoostClassifier_staged_score)`;
    return this._py`res_AdaBoostClassifier_staged_score.tolist() if hasattr(res_AdaBoostClassifier_staged_score, 'tolist') else res_AdaBoostClassifier_staged_score`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_ = bridgeAdaBoostClassifier[${this.id}].estimator_`;
      return this._py`attr_AdaBoostClassifier_estimator_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_, 'tolist') else attr_AdaBoostClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimators_ = bridgeAdaBoostClassifier[${this.id}].estimators_`;
      return this._py`attr_AdaBoostClassifier_estimators_.tolist() if hasattr(attr_AdaBoostClassifier_estimators_, 'tolist') else attr_AdaBoostClassifier_estimators_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_classes_ = bridgeAdaBoostClassifier[${this.id}].classes_`;
      return this._py`attr_AdaBoostClassifier_classes_.tolist() if hasattr(attr_AdaBoostClassifier_classes_, 'tolist') else attr_AdaBoostClassifier_classes_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_n_classes_ = bridgeAdaBoostClassifier[${this.id}].n_classes_`;
      return this._py`attr_AdaBoostClassifier_n_classes_.tolist() if hasattr(attr_AdaBoostClassifier_n_classes_, 'tolist') else attr_AdaBoostClassifier_n_classes_`;
    })();
  }
  /**
    Weights for each estimator in the boosted ensemble.
   */
  get estimator_weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_weights_ = bridgeAdaBoostClassifier[${this.id}].estimator_weights_`;
      return this._py`attr_AdaBoostClassifier_estimator_weights_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_weights_, 'tolist') else attr_AdaBoostClassifier_estimator_weights_`;
    })();
  }
  /**
    Classification error for each estimator in the boosted ensemble.
   */
  get estimator_errors_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_errors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_errors_ = bridgeAdaBoostClassifier[${this.id}].estimator_errors_`;
      return this._py`attr_AdaBoostClassifier_estimator_errors_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_errors_, 'tolist') else attr_AdaBoostClassifier_estimator_errors_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_n_features_in_ = bridgeAdaBoostClassifier[${this.id}].n_features_in_`;
      return this._py`attr_AdaBoostClassifier_n_features_in_.tolist() if hasattr(attr_AdaBoostClassifier_n_features_in_, 'tolist') else attr_AdaBoostClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_feature_names_in_ = bridgeAdaBoostClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_AdaBoostClassifier_feature_names_in_.tolist() if hasattr(attr_AdaBoostClassifier_feature_names_in_, 'tolist') else attr_AdaBoostClassifier_feature_names_in_`;
    })();
  }
};
export {
  AdaBoostClassifier
};
//# sourceMappingURL=AdaBoostClassifier.js.map