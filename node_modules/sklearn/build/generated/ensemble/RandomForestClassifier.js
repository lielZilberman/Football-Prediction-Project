// src/generated/ensemble/RandomForestClassifier.ts
import crypto from "node:crypto";
var RandomForestClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `RandomForestClassifier${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "RandomForestClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import RandomForestClassifier
try: bridgeRandomForestClassifier
except NameError: bridgeRandomForestClassifier = {}
`;
    await this._py.ex`ctor_RandomForestClassifier = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}}

ctor_RandomForestClassifier = {k: v for k, v in ctor_RandomForestClassifier.items() if v is not None}`;
    await this._py.ex`bridgeRandomForestClassifier[${this.id}] = RandomForestClassifier(**ctor_RandomForestClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeRandomForestClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestClassifier must call init() before apply()");
    }
    await this._py.ex`pms_RandomForestClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_apply = {k: v for k, v in pms_RandomForestClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_apply = bridgeRandomForestClassifier[${this.id}].apply(**pms_RandomForestClassifier_apply)`;
    return this._py`res_RandomForestClassifier_apply.tolist() if hasattr(res_RandomForestClassifier_apply, 'tolist') else res_RandomForestClassifier_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_decision_path = {k: v for k, v in pms_RandomForestClassifier_decision_path.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_decision_path = bridgeRandomForestClassifier[${this.id}].decision_path(**pms_RandomForestClassifier_decision_path)`;
    return this._py`res_RandomForestClassifier_decision_path.tolist() if hasattr(res_RandomForestClassifier_decision_path, 'tolist') else res_RandomForestClassifier_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestClassifier must call init() before fit()");
    }
    await this._py.ex`pms_RandomForestClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomForestClassifier_fit = {k: v for k, v in pms_RandomForestClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_fit = bridgeRandomForestClassifier[${this.id}].fit(**pms_RandomForestClassifier_fit)`;
    return this._py`res_RandomForestClassifier_fit.tolist() if hasattr(res_RandomForestClassifier_fit, 'tolist') else res_RandomForestClassifier_fit`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates. That is, the predicted class is the one with highest mean probability estimate across the trees.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_predict = {k: v for k, v in pms_RandomForestClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_predict = bridgeRandomForestClassifier[${this.id}].predict(**pms_RandomForestClassifier_predict)`;
    return this._py`res_RandomForestClassifier_predict.tolist() if hasattr(res_RandomForestClassifier_predict, 'tolist') else res_RandomForestClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the trees in the forest.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_predict_log_proba = {k: v for k, v in pms_RandomForestClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_predict_log_proba = bridgeRandomForestClassifier[${this.id}].predict_log_proba(**pms_RandomForestClassifier_predict_log_proba)`;
    return this._py`res_RandomForestClassifier_predict_log_proba.tolist() if hasattr(res_RandomForestClassifier_predict_log_proba, 'tolist') else res_RandomForestClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample are computed as the mean predicted class probabilities of the trees in the forest. The class probability of a single tree is the fraction of samples of the same class in a leaf.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_RandomForestClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_RandomForestClassifier_predict_proba = {k: v for k, v in pms_RandomForestClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_predict_proba = bridgeRandomForestClassifier[${this.id}].predict_proba(**pms_RandomForestClassifier_predict_proba)`;
    return this._py`res_RandomForestClassifier_predict_proba.tolist() if hasattr(res_RandomForestClassifier_predict_proba, 'tolist') else res_RandomForestClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("RandomForestClassifier must call init() before score()");
    }
    await this._py.ex`pms_RandomForestClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_RandomForestClassifier_score = {k: v for k, v in pms_RandomForestClassifier_score.items() if v is not None}`;
    await this._py.ex`res_RandomForestClassifier_score = bridgeRandomForestClassifier[${this.id}].score(**pms_RandomForestClassifier_score)`;
    return this._py`res_RandomForestClassifier_score.tolist() if hasattr(res_RandomForestClassifier_score, 'tolist') else res_RandomForestClassifier_score`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_estimator_ = bridgeRandomForestClassifier[${this.id}].estimator_`;
      return this._py`attr_RandomForestClassifier_estimator_.tolist() if hasattr(attr_RandomForestClassifier_estimator_, 'tolist') else attr_RandomForestClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_estimators_ = bridgeRandomForestClassifier[${this.id}].estimators_`;
      return this._py`attr_RandomForestClassifier_estimators_.tolist() if hasattr(attr_RandomForestClassifier_estimators_, 'tolist') else attr_RandomForestClassifier_estimators_`;
    })();
  }
  /**
    The classes labels (single output problem), or a list of arrays of class labels (multi-output problem).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_classes_ = bridgeRandomForestClassifier[${this.id}].classes_`;
      return this._py`attr_RandomForestClassifier_classes_.tolist() if hasattr(attr_RandomForestClassifier_classes_, 'tolist') else attr_RandomForestClassifier_classes_`;
    })();
  }
  /**
    The number of classes (single output problem), or a list containing the number of classes for each output (multi-output problem).
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_n_classes_ = bridgeRandomForestClassifier[${this.id}].n_classes_`;
      return this._py`attr_RandomForestClassifier_n_classes_.tolist() if hasattr(attr_RandomForestClassifier_n_classes_, 'tolist') else attr_RandomForestClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_n_features_in_ = bridgeRandomForestClassifier[${this.id}].n_features_in_`;
      return this._py`attr_RandomForestClassifier_n_features_in_.tolist() if hasattr(attr_RandomForestClassifier_n_features_in_, 'tolist') else attr_RandomForestClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_feature_names_in_ = bridgeRandomForestClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_RandomForestClassifier_feature_names_in_.tolist() if hasattr(attr_RandomForestClassifier_feature_names_in_, 'tolist') else attr_RandomForestClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_n_outputs_ = bridgeRandomForestClassifier[${this.id}].n_outputs_`;
      return this._py`attr_RandomForestClassifier_n_outputs_.tolist() if hasattr(attr_RandomForestClassifier_n_outputs_, 'tolist') else attr_RandomForestClassifier_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_oob_score_ = bridgeRandomForestClassifier[${this.id}].oob_score_`;
      return this._py`attr_RandomForestClassifier_oob_score_.tolist() if hasattr(attr_RandomForestClassifier_oob_score_, 'tolist') else attr_RandomForestClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n\_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob\_decision\_function\_` might contain NaN. This attribute exists only when `oob\_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This RandomForestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "RandomForestClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_RandomForestClassifier_oob_decision_function_ = bridgeRandomForestClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_RandomForestClassifier_oob_decision_function_.tolist() if hasattr(attr_RandomForestClassifier_oob_decision_function_, 'tolist') else attr_RandomForestClassifier_oob_decision_function_`;
    })();
  }
};
export {
  RandomForestClassifier
};
//# sourceMappingURL=RandomForestClassifier.js.map