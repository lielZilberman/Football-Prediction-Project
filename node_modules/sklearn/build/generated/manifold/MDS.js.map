{"version":3,"sources":["../../../src/generated/manifold/MDS.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Multidimensional scaling.\n\n  Read more in the [User Guide](../manifold.html#multidimensional-scaling).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.MDS.html)\n */\nexport class MDS {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of dimensions in which to immerse the dissimilarities.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      If `true`, perform metric MDS; otherwise, perform nonmetric MDS. When `false` (i.e. non-metric MDS), dissimilarities with 0 are considered as missing values.\n\n      @defaultValue `true`\n     */\n    metric?: boolean\n\n    /**\n      Number of times the SMACOF algorithm will be run with different initializations. The final results will be the best output of the runs, determined by the run with the smallest final stress.\n\n      @defaultValue `4`\n     */\n    n_init?: number\n\n    /**\n      Maximum number of iterations of the SMACOF algorithm for a single run.\n\n      @defaultValue `300`\n     */\n    max_iter?: number\n\n    /**\n      Level of verbosity.\n\n      @defaultValue `0`\n     */\n    verbose?: number\n\n    /**\n      Relative tolerance with respect to stress at which to declare convergence. The value of `eps` should be tuned separately depending on whether or not `normalized\\_stress` is being used.\n\n      @defaultValue `0.001`\n     */\n    eps?: number\n\n    /**\n      The number of jobs to use for the computation. If multiple initializations are used (`n\\_init`), each run of the algorithm is computed in parallel.\n\n      `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend \"(in joblib v1.3.0.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Determines the random number generator used to initialize the centers. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Dissimilarity measure to use:\n\n      @defaultValue `'euclidean'`\n     */\n    dissimilarity?: 'euclidean' | 'precomputed'\n\n    /**\n      Whether use and return normed stress value (Stress-1) instead of raw stress calculated by default. Only supported in non-metric MDS.\n     */\n    normalized_stress?: boolean\n  }) {\n    this.id = `MDS${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('MDS.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import MDS\ntry: bridgeMDS\nexcept NameError: bridgeMDS = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MDS = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'metric': ${this.opts['metric'] ?? undefined}, 'n_init': ${\n      this.opts['n_init'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'verbose': ${\n      this.opts['verbose'] ?? undefined\n    }, 'eps': ${this.opts['eps'] ?? undefined}, 'n_jobs': ${\n      this.opts['n_jobs'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'dissimilarity': ${\n      this.opts['dissimilarity'] ?? undefined\n    }, 'normalized_stress': ${this.opts['normalized_stress'] ?? undefined}}\n\nctor_MDS = {k: v for k, v in ctor_MDS.items() if v is not None}`\n\n    await this._py.ex`bridgeMDS[${this.id}] = MDS(**ctor_MDS)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMDS[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the position of the points in the embedding space.\n   */\n  async fit(opts: {\n    /**\n      Input data. If `dissimilarity=='precomputed'`, the input should be the dissimilarity matrix.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Starting configuration of the embedding to initialize the SMACOF algorithm. By default, the algorithm is initialized with a randomly chosen array.\n     */\n    init?: NDArray[]\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MDS_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'init': np.array(${opts['init'] ?? undefined}) if ${\n      opts['init'] !== undefined\n    } else None}\n\npms_MDS_fit = {k: v for k, v in pms_MDS_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py.ex`res_MDS_fit = bridgeMDS[${this.id}].fit(**pms_MDS_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MDS_fit.tolist() if hasattr(res_MDS_fit, 'tolist') else res_MDS_fit`\n  }\n\n  /**\n    Fit the data from `X`, and returns the embedded coordinates.\n   */\n  async fit_transform(opts: {\n    /**\n      Input data. If `dissimilarity=='precomputed'`, the input should be the dissimilarity matrix.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Starting configuration of the embedding to initialize the SMACOF algorithm. By default, the algorithm is initialized with a randomly chosen array.\n     */\n    init?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_MDS_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'init': np.array(${opts['init'] ?? undefined}) if ${\n      opts['init'] !== undefined\n    } else None}\n\npms_MDS_fit_transform = {k: v for k, v in pms_MDS_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MDS_fit_transform = bridgeMDS[${this.id}].fit_transform(**pms_MDS_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MDS_fit_transform.tolist() if hasattr(res_MDS_fit_transform, 'tolist') else res_MDS_fit_transform`\n  }\n\n  /**\n    Stores the position of the dataset in the embedding space.\n   */\n  get embedding_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing embedding_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_MDS_embedding_ = bridgeMDS[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_embedding_.tolist() if hasattr(attr_MDS_embedding_, 'tolist') else attr_MDS_embedding_`\n    })()\n  }\n\n  /**\n    The final value of the stress (sum of squared distance of the disparities and the distances for all constrained points). If `normalized\\_stress=True`, and `metric=False` returns Stress-1. A value of 0 indicates “perfect” fit, 0.025 excellent, 0.05 good, 0.1 fair, and 0.2 poor [\\[1\\]](#r77760563872b-1).\n   */\n  get stress_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing stress_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_MDS_stress_ = bridgeMDS[${this.id}].stress_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_stress_.tolist() if hasattr(attr_MDS_stress_, 'tolist') else attr_MDS_stress_`\n    })()\n  }\n\n  /**\n    Pairwise dissimilarities between the points. Symmetric matrix that:\n   */\n  get dissimilarity_matrix_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MDS must call init() before accessing dissimilarity_matrix_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MDS_dissimilarity_matrix_ = bridgeMDS[${this.id}].dissimilarity_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_dissimilarity_matrix_.tolist() if hasattr(attr_MDS_dissimilarity_matrix_, 'tolist') else attr_MDS_dissimilarity_matrix_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MDS_n_features_in_ = bridgeMDS[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_n_features_in_.tolist() if hasattr(attr_MDS_n_features_in_, 'tolist') else attr_MDS_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing feature_names_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MDS_feature_names_in_ = bridgeMDS[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_feature_names_in_.tolist() if hasattr(attr_MDS_feature_names_in_, 'tolist') else attr_MDS_feature_names_in_`\n    })()\n  }\n\n  /**\n    The number of iterations corresponding to the best stress.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This MDS instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('MDS must call init() before accessing n_iter_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_MDS_n_iter_ = bridgeMDS[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MDS_n_iter_.tolist() if hasattr(attr_MDS_n_iter_, 'tolist') else attr_MDS_n_iter_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}