{"version":3,"sources":["../../../src/generated/manifold/Isomap.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Isomap Embedding.\n\n  Non-linear dimensionality reduction through Isometric Mapping\n\n  Read more in the [User Guide](../manifold.html#isomap).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.Isomap.html)\n */\nexport class Isomap {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of neighbors to consider for each point. If `n\\_neighbors` is an int, then `radius` must be `undefined`.\n\n      @defaultValue `5`\n     */\n    n_neighbors?: number\n\n    /**\n      Limiting distance of neighbors to return. If `radius` is a float, then `n\\_neighbors` must be set to `undefined`.\n     */\n    radius?: number\n\n    /**\n      Number of coordinates for the manifold.\n\n      @defaultValue `2`\n     */\n    n_components?: number\n\n    /**\n      ‘auto’ : Attempt to choose the most efficient solver for the given problem.\n\n      ‘arpack’ : Use Arnoldi decomposition to find the eigenvalues and eigenvectors.\n\n      ‘dense’ : Use a direct solver (i.e. LAPACK) for the eigenvalue decomposition.\n\n      @defaultValue `'auto'`\n     */\n    eigen_solver?: 'auto' | 'arpack' | 'dense'\n\n    /**\n      Convergence tolerance passed to arpack or lobpcg. not used if eigen\\_solver == ‘dense’.\n\n      @defaultValue `0`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations for the arpack solver. not used if eigen\\_solver == ‘dense’.\n     */\n    max_iter?: number\n\n    /**\n      Method to use in finding shortest path.\n\n      ‘auto’ : attempt to choose the best algorithm automatically.\n\n      ‘FW’ : Floyd-Warshall algorithm.\n\n      ‘D’ : Dijkstra’s algorithm.\n\n      @defaultValue `'auto'`\n     */\n    path_method?: 'auto' | 'FW' | 'D'\n\n    /**\n      Algorithm to use for nearest neighbors search, passed to neighbors.NearestNeighbors instance.\n\n      @defaultValue `'auto'`\n     */\n    neighbors_algorithm?: 'auto' | 'brute' | 'kd_tree' | 'ball_tree'\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend \"(in joblib v1.3.0.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      The metric to use when calculating distance between instances in a feature array. If metric is a string or callable, it must be one of the options allowed by [`sklearn.metrics.pairwise\\_distances`](sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances \"sklearn.metrics.pairwise_distances\") for its metric parameter. If metric is “precomputed”, X is assumed to be a distance matrix and must be square. X may be a [Glossary](../../glossary.html#term-sparse-graph).\n\n      @defaultValue `'minkowski'`\n     */\n    metric?: any\n\n    /**\n      Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise\\_distances. When p = 1, this is equivalent to using manhattan\\_distance (l1), and euclidean\\_distance (l2) for p = 2. For arbitrary p, minkowski\\_distance (l\\_p) is used.\n\n      @defaultValue `2`\n     */\n    p?: number\n\n    /**\n      Additional keyword arguments for the metric function.\n     */\n    metric_params?: any\n  }) {\n    this.id = `Isomap${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Isomap.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.manifold import Isomap\ntry: bridgeIsomap\nexcept NameError: bridgeIsomap = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_Isomap = {'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'radius': ${this.opts['radius'] ?? undefined}, 'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'eigen_solver': ${this.opts['eigen_solver'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'path_method': ${\n      this.opts['path_method'] ?? undefined\n    }, 'neighbors_algorithm': ${\n      this.opts['neighbors_algorithm'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'p': ${this.opts['p'] ?? undefined}, 'metric_params': ${\n      this.opts['metric_params'] ?? undefined\n    }}\n\nctor_Isomap = {k: v for k, v in ctor_Isomap.items() if v is not None}`\n\n    await this._py.ex`bridgeIsomap[${this.id}] = Isomap(**ctor_Isomap)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeIsomap[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Compute the embedding vectors for data X.\n   */\n  async fit(opts: {\n    /**\n      Sample data, shape = (n\\_samples, n\\_features), in the form of a numpy array, sparse matrix, precomputed tree, or NearestNeighbors object.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_fit = {'X': ${opts['X'] ?? undefined}, 'y': ${\n      opts['y'] ?? undefined\n    }}\n\npms_Isomap_fit = {k: v for k, v in pms_Isomap_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_fit = bridgeIsomap[${this.id}].fit(**pms_Isomap_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_fit.tolist() if hasattr(res_Isomap_fit, 'tolist') else res_Isomap_fit`\n  }\n\n  /**\n    Fit the model from data in X and transform X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_fit_transform = {'X': ${\n      opts['X'] ?? undefined\n    }, 'y': ${opts['y'] ?? undefined}}\n\npms_Isomap_fit_transform = {k: v for k, v in pms_Isomap_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_fit_transform = bridgeIsomap[${this.id}].fit_transform(**pms_Isomap_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_fit_transform.tolist() if hasattr(res_Isomap_fit_transform, 'tolist') else res_Isomap_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in [`fit`](#sklearn.manifold.Isomap.fit \"sklearn.manifold.Isomap.fit\").\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before get_feature_names_out()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_Isomap_get_feature_names_out = {k: v for k, v in pms_Isomap_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_get_feature_names_out = bridgeIsomap[${this.id}].get_feature_names_out(**pms_Isomap_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_get_feature_names_out.tolist() if hasattr(res_Isomap_get_feature_names_out, 'tolist') else res_Isomap_get_feature_names_out`\n  }\n\n  /**\n    Compute the reconstruction error for the embedding.\n   */\n  async reconstruction_error(opts: {\n    /**\n      Reconstruction error.\n     */\n    reconstruction_error?: number\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before reconstruction_error()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Isomap_reconstruction_error = {'reconstruction_error': ${\n      opts['reconstruction_error'] ?? undefined\n    }}\n\npms_Isomap_reconstruction_error = {k: v for k, v in pms_Isomap_reconstruction_error.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_reconstruction_error = bridgeIsomap[${this.id}].reconstruction_error(**pms_Isomap_reconstruction_error)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_reconstruction_error.tolist() if hasattr(res_Isomap_reconstruction_error, 'tolist') else res_Isomap_reconstruction_error`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_Isomap_set_output = {k: v for k, v in pms_Isomap_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_set_output = bridgeIsomap[${this.id}].set_output(**pms_Isomap_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_set_output.tolist() if hasattr(res_Isomap_set_output, 'tolist') else res_Isomap_set_output`\n  }\n\n  /**\n    Transform X.\n\n    This is implemented by linking the points X into the graph of geodesic distances of the training data. First the `n\\_neighbors` nearest neighbors of X are found in the training data, and from these the shortest geodesic distances from each point in X to each point in the training data are computed in order to construct the kernel. The embedding of X is the projection of this kernel onto the embedding vectors of the training set.\n   */\n  async transform(opts: {\n    /**\n      If neighbors\\_algorithm=’precomputed’, X is assumed to be a distance matrix or a sparse graph of shape (n\\_queries, n\\_samples\\_fit).\n     */\n    X?: ArrayLike | SparseMatrix\n  }): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_Isomap_transform = {'X': ${opts['X'] ?? undefined}}\n\npms_Isomap_transform = {k: v for k, v in pms_Isomap_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Isomap_transform = bridgeIsomap[${this.id}].transform(**pms_Isomap_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Isomap_transform.tolist() if hasattr(res_Isomap_transform, 'tolist') else res_Isomap_transform`\n  }\n\n  /**\n    Stores the embedding vectors.\n   */\n  get embedding_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing embedding_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_embedding_ = bridgeIsomap[${this.id}].embedding_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_embedding_.tolist() if hasattr(attr_Isomap_embedding_, 'tolist') else attr_Isomap_embedding_`\n    })()\n  }\n\n  /**\n    [`KernelPCA`](sklearn.decomposition.KernelPCA.html#sklearn.decomposition.KernelPCA \"sklearn.decomposition.KernelPCA\") object used to implement the embedding.\n   */\n  get kernel_pca_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing kernel_pca_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_kernel_pca_ = bridgeIsomap[${this.id}].kernel_pca_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_kernel_pca_.tolist() if hasattr(attr_Isomap_kernel_pca_, 'tolist') else attr_Isomap_kernel_pca_`\n    })()\n  }\n\n  /**\n    Stores nearest neighbors instance, including BallTree or KDtree if applicable.\n   */\n  get nbrs_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing nbrs_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py.ex`attr_Isomap_nbrs_ = bridgeIsomap[${this.id}].nbrs_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_nbrs_.tolist() if hasattr(attr_Isomap_nbrs_, 'tolist') else attr_Isomap_nbrs_`\n    })()\n  }\n\n  /**\n    Stores the geodesic distance matrix of training data.\n   */\n  get dist_matrix_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing dist_matrix_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_dist_matrix_ = bridgeIsomap[${this.id}].dist_matrix_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_dist_matrix_.tolist() if hasattr(attr_Isomap_dist_matrix_, 'tolist') else attr_Isomap_dist_matrix_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Isomap must call init() before accessing n_features_in_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_n_features_in_ = bridgeIsomap[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_n_features_in_.tolist() if hasattr(attr_Isomap_n_features_in_, 'tolist') else attr_Isomap_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Isomap instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Isomap must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_Isomap_feature_names_in_ = bridgeIsomap[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_Isomap_feature_names_in_.tolist() if hasattr(attr_Isomap_feature_names_in_, 'tolist') else attr_Isomap_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}