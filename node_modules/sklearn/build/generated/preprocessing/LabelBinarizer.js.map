{"version":3,"sources":["../../../src/generated/preprocessing/LabelBinarizer.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Binarize labels in a one-vs-all fashion.\n\n  Several regression and binary classification algorithms are available in scikit-learn. A simple way to extend these algorithms to the multi-class classification case is to use the so-called one-vs-all scheme.\n\n  At learning time, this simply consists in learning one regressor or binary classifier per class. In doing so, one needs to convert multi-class labels to binary labels (belong or does not belong to the class). LabelBinarizer makes this process easy with the transform method.\n\n  At prediction time, one assigns the class for which the corresponding model gave the greatest confidence. LabelBinarizer makes this easy with the inverse\\_transform method.\n\n  Read more in the [User Guide](../preprocessing_targets.html#preprocessing-targets).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelBinarizer.html)\n */\nexport class LabelBinarizer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Value with which negative labels must be encoded.\n\n      @defaultValue `0`\n     */\n    neg_label?: number\n\n    /**\n      Value with which positive labels must be encoded.\n\n      @defaultValue `1`\n     */\n    pos_label?: number\n\n    /**\n      True if the returned array from transform is desired to be in sparse CSR format.\n\n      @defaultValue `false`\n     */\n    sparse_output?: boolean\n  }) {\n    this.id = `LabelBinarizer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelBinarizer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.preprocessing import LabelBinarizer\ntry: bridgeLabelBinarizer\nexcept NameError: bridgeLabelBinarizer = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelBinarizer = {'neg_label': ${\n      this.opts['neg_label'] ?? undefined\n    }, 'pos_label': ${this.opts['pos_label'] ?? undefined}, 'sparse_output': ${\n      this.opts['sparse_output'] ?? undefined\n    }}\n\nctor_LabelBinarizer = {k: v for k, v in ctor_LabelBinarizer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelBinarizer[${this.id}] = LabelBinarizer(**ctor_LabelBinarizer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelBinarizer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit label binarizer.\n   */\n  async fit(opts: {\n    /**\n      Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification.\n     */\n    y?: NDArray\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_fit = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelBinarizer_fit = {k: v for k, v in pms_LabelBinarizer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_fit = bridgeLabelBinarizer[${this.id}].fit(**pms_LabelBinarizer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_fit.tolist() if hasattr(res_LabelBinarizer_fit, 'tolist') else res_LabelBinarizer_fit`\n  }\n\n  /**\n    Fit label binarizer/transform multi-class labels to binary labels.\n\n    The output of transform is sometimes referred to as the 1-of-K coding scheme.\n   */\n  async fit_transform(opts: {\n    /**\n      Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification. Sparse matrix can be CSR, CSC, COO, DOK, or LIL.\n     */\n    y?: NDArray | SparseMatrix\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_fit_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelBinarizer_fit_transform = {k: v for k, v in pms_LabelBinarizer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_fit_transform = bridgeLabelBinarizer[${this.id}].fit_transform(**pms_LabelBinarizer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_fit_transform.tolist() if hasattr(res_LabelBinarizer_fit_transform, 'tolist') else res_LabelBinarizer_fit_transform`\n  }\n\n  /**\n    Transform binary labels back to multi-class labels.\n   */\n  async inverse_transform(opts: {\n    /**\n      Target values. All sparse matrices are converted to CSR before inverse transformation.\n     */\n    Y?: NDArray | SparseMatrix[]\n\n    /**\n      Threshold used in the binary and multi-label cases.\n\n      Use 0 when `Y` contains the output of decision\\_function (classifier). Use 0.5 when `Y` contains the output of predict\\_proba.\n\n      If `undefined`, the threshold is assumed to be half way between neg\\_label and pos\\_label.\n     */\n    threshold?: number\n  }): Promise<NDArray | SparseMatrix> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before inverse_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_inverse_transform = {'Y': np.array(${\n      opts['Y'] ?? undefined\n    }) if ${opts['Y'] !== undefined} else None, 'threshold': ${\n      opts['threshold'] ?? undefined\n    }}\n\npms_LabelBinarizer_inverse_transform = {k: v for k, v in pms_LabelBinarizer_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_inverse_transform = bridgeLabelBinarizer[${this.id}].inverse_transform(**pms_LabelBinarizer_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_inverse_transform.tolist() if hasattr(res_LabelBinarizer_inverse_transform, 'tolist') else res_LabelBinarizer_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_LabelBinarizer_set_output = {k: v for k, v in pms_LabelBinarizer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_set_output = bridgeLabelBinarizer[${this.id}].set_output(**pms_LabelBinarizer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_set_output.tolist() if hasattr(res_LabelBinarizer_set_output, 'tolist') else res_LabelBinarizer_set_output`\n  }\n\n  /**\n    Transform multi-class labels to binary labels.\n\n    The output of transform is sometimes referred to by some authors as the 1-of-K coding scheme.\n   */\n  async transform(opts: {\n    /**\n      Target values. The 2-d matrix should only contain 0 and 1, represents multilabel classification. Sparse matrix can be CSR, CSC, COO, DOK, or LIL.\n     */\n    y?: SparseMatrix\n  }): Promise<NDArray | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelBinarizer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelBinarizer_transform = {'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelBinarizer_transform = {k: v for k, v in pms_LabelBinarizer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelBinarizer_transform = bridgeLabelBinarizer[${this.id}].transform(**pms_LabelBinarizer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelBinarizer_transform.tolist() if hasattr(res_LabelBinarizer_transform, 'tolist') else res_LabelBinarizer_transform`\n  }\n\n  /**\n    Holds the label for each class.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelBinarizer_classes_ = bridgeLabelBinarizer[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelBinarizer_classes_.tolist() if hasattr(attr_LabelBinarizer_classes_, 'tolist') else attr_LabelBinarizer_classes_`\n    })()\n  }\n\n  /**\n    Represents the type of the target data as evaluated by utils.multiclass.type\\_of\\_target. Possible type are ‘continuous’, ‘continuous-multioutput’, ‘binary’, ‘multiclass’, ‘multiclass-multioutput’, ‘multilabel-indicator’, and ‘unknown’.\n   */\n  get y_type_(): Promise<string> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before accessing y_type_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelBinarizer_y_type_ = bridgeLabelBinarizer[${this.id}].y_type_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelBinarizer_y_type_.tolist() if hasattr(attr_LabelBinarizer_y_type_, 'tolist') else attr_LabelBinarizer_y_type_`\n    })()\n  }\n\n  /**\n    True if the input data to transform is given as a sparse matrix, `false` otherwise.\n   */\n  get sparse_input_(): Promise<boolean> {\n    if (this._isDisposed) {\n      throw new Error('This LabelBinarizer instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelBinarizer must call init() before accessing sparse_input_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelBinarizer_sparse_input_ = bridgeLabelBinarizer[${this.id}].sparse_input_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelBinarizer_sparse_input_.tolist() if hasattr(attr_LabelBinarizer_sparse_input_, 'tolist') else attr_LabelBinarizer_sparse_input_`\n    })()\n  }\n}\n"],"mappings":";AAGA,OAAO,YAAY;AAiBZ,IAAM,iBAAN,MAAqB;AAAA,EAQ1B,YAAY,MAqBT;AAxBH,0BAA0B;AAC1B,uBAAuB;AAwBrB,SAAK,KAAK,iBAAiB,OAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAC3D,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IAAI,yCACb,KAAK,KAAK,WAAW,KAAK,wBACV,KAAK,KAAK,WAAW,KAAK,4BAC1C,KAAK,KAAK,eAAe,KAAK;AAAA;AAAA;AAKhC,UAAM,KAAK,IACR,0BAA0B,KAAK;AAElC,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,8BAA8B,KAAK;AAElD,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAKO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAGA,UAAM,KAAK,IAAI,6CACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,mDAAmD,KAAK;AAG3D,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAc,MAKkB;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAGA,UAAM,KAAK,IAAI,uDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,6DAA6D,KAAK;AAGrE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,MAcY;AAClC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,2DACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,kCACpB,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,iEAAiE,KAAK;AAGzE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,MAKA;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACvE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,WAAW,KAAK;AAAA;AAAA;AAMvB,UAAM,KAAK,IACR,0DAA0D,KAAK;AAGlE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU,MAKsB;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAGA,UAAM,KAAK,IAAI,mDACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,yDAAyD,KAAK;AAGjE,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAA6B;AAC/B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,yDAAyD,KAAK;AAGjE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA2B;AAC7B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,wDAAwD,KAAK;AAGhE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,gBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,8DAA8D,KAAK;AAGtE,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;","names":[]}