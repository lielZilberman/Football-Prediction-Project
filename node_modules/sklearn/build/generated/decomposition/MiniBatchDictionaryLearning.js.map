{"version":3,"sources":["../../../src/generated/decomposition/MiniBatchDictionaryLearning.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Mini-batch dictionary learning.\n\n  Finds a dictionary (a set of atoms) that performs well at sparsely encoding the fitted data.\n\n  Solves the optimization problem:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.MiniBatchDictionaryLearning.html)\n */\nexport class MiniBatchDictionaryLearning {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of dictionary elements to extract.\n     */\n    n_components?: number\n\n    /**\n      Sparsity controlling parameter.\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Total number of iterations over data batches to perform.\n\n      @defaultValue `1000`\n     */\n    n_iter?: number\n\n    /**\n      Maximum number of iterations over the complete dataset before stopping independently of any early stopping criterion heuristics. If `max\\_iter` is not `undefined`, `n\\_iter` is ignored.\n     */\n    max_iter?: number\n\n    /**\n      The algorithm used:\n\n      @defaultValue `'lars'`\n     */\n    fit_algorithm?: 'lars' | 'cd'\n\n    /**\n      Number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend \"(in joblib v1.3.0.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Number of samples in each mini-batch.\n\n      @defaultValue `3`\n     */\n    batch_size?: number\n\n    /**\n      Whether to shuffle the samples before forming batches.\n\n      @defaultValue `true`\n     */\n    shuffle?: boolean\n\n    /**\n      Initial value of the dictionary for warm restart scenarios.\n     */\n    dict_init?: NDArray[]\n\n    /**\n      Algorithm used to transform the data:\n\n      @defaultValue `'omp'`\n     */\n    transform_algorithm?:\n      | 'lasso_lars'\n      | 'lasso_cd'\n      | 'lars'\n      | 'omp'\n      | 'threshold'\n\n    /**\n      Number of nonzero coefficients to target in each column of the solution. This is only used by `algorithm='lars'` and `algorithm='omp'`. If `undefined`, then `transform\\_n\\_nonzero\\_coefs=int(n\\_features / 10)`.\n     */\n    transform_n_nonzero_coefs?: number\n\n    /**\n      If `algorithm='lasso\\_lars'` or `algorithm='lasso\\_cd'`, `alpha` is the penalty applied to the L1 norm. If `algorithm='threshold'`, `alpha` is the absolute value of the threshold below which coefficients will be squashed to zero. If `undefined`, defaults to `alpha`.\n     */\n    transform_alpha?: number\n\n    /**\n      To control the verbosity of the procedure.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean | number\n\n    /**\n      Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers.\n\n      @defaultValue `false`\n     */\n    split_sign?: boolean\n\n    /**\n      Used for initializing the dictionary when `dict\\_init` is not specified, randomly shuffling the data when `shuffle` is set to `true`, and updating the dictionary. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      Whether to enforce positivity when finding the code.\n\n      @defaultValue `false`\n     */\n    positive_code?: boolean\n\n    /**\n      Whether to enforce positivity when finding the dictionary.\n\n      @defaultValue `false`\n     */\n    positive_dict?: boolean\n\n    /**\n      Maximum number of iterations to perform if `algorithm='lasso\\_cd'` or `'lasso\\_lars'`.\n\n      @defaultValue `1000`\n     */\n    transform_max_iter?: number\n\n    /**\n      A callable that gets invoked at the end of each iteration.\n     */\n    callback?: any\n\n    /**\n      Control early stopping based on the norm of the differences in the dictionary between 2 steps. Used only if `max\\_iter` is not `undefined`.\n\n      To disable early stopping based on changes in the dictionary, set `tol` to 0.0.\n\n      @defaultValue `0.001`\n     */\n    tol?: number\n\n    /**\n      Control early stopping based on the consecutive number of mini batches that does not yield an improvement on the smoothed cost function. Used only if `max\\_iter` is not `undefined`.\n\n      To disable convergence detection based on cost function, set `max\\_no\\_improvement` to `undefined`.\n\n      @defaultValue `10`\n     */\n    max_no_improvement?: number\n  }) {\n    this.id = `MiniBatchDictionaryLearning${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'MiniBatchDictionaryLearning.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import MiniBatchDictionaryLearning\ntry: bridgeMiniBatchDictionaryLearning\nexcept NameError: bridgeMiniBatchDictionaryLearning = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_MiniBatchDictionaryLearning = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'alpha': ${this.opts['alpha'] ?? undefined}, 'n_iter': ${\n      this.opts['n_iter'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'fit_algorithm': ${\n      this.opts['fit_algorithm'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'batch_size': ${\n      this.opts['batch_size'] ?? undefined\n    }, 'shuffle': ${this.opts['shuffle'] ?? undefined}, 'dict_init': np.array(${\n      this.opts['dict_init'] ?? undefined\n    }) if ${\n      this.opts['dict_init'] !== undefined\n    } else None, 'transform_algorithm': ${\n      this.opts['transform_algorithm'] ?? undefined\n    }, 'transform_n_nonzero_coefs': ${\n      this.opts['transform_n_nonzero_coefs'] ?? undefined\n    }, 'transform_alpha': ${\n      this.opts['transform_alpha'] ?? undefined\n    }, 'verbose': ${this.opts['verbose'] ?? undefined}, 'split_sign': ${\n      this.opts['split_sign'] ?? undefined\n    }, 'random_state': ${\n      this.opts['random_state'] ?? undefined\n    }, 'positive_code': ${\n      this.opts['positive_code'] ?? undefined\n    }, 'positive_dict': ${\n      this.opts['positive_dict'] ?? undefined\n    }, 'transform_max_iter': ${\n      this.opts['transform_max_iter'] ?? undefined\n    }, 'callback': ${this.opts['callback'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_no_improvement': ${this.opts['max_no_improvement'] ?? undefined}}\n\nctor_MiniBatchDictionaryLearning = {k: v for k, v in ctor_MiniBatchDictionaryLearning.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeMiniBatchDictionaryLearning[${this.id}] = MiniBatchDictionaryLearning(**ctor_MiniBatchDictionaryLearning)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeMiniBatchDictionaryLearning[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_MiniBatchDictionaryLearning_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_MiniBatchDictionaryLearning_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_fit = bridgeMiniBatchDictionaryLearning[${this.id}].fit(**pms_MiniBatchDictionaryLearning_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit, 'tolist') else res_MiniBatchDictionaryLearning_fit`\n  }\n\n  /**\n    Fit to data, then transform it.\n\n    Fits transformer to `X` and `y` with optional parameters `fit\\_params` and returns a transformed version of `X`.\n   */\n  async fit_transform(opts: {\n    /**\n      Input samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (`undefined` for unsupervised transformations).\n     */\n    y?: ArrayLike\n\n    /**\n      Additional fit parameters.\n     */\n    fit_params?: any\n  }): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'fit_params': ${\n      opts['fit_params'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_fit_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_fit_transform = bridgeMiniBatchDictionaryLearning[${this.id}].fit_transform(**pms_MiniBatchDictionaryLearning_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_fit_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit_transform, 'tolist') else res_MiniBatchDictionaryLearning_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in [`fit`](#sklearn.decomposition.MiniBatchDictionaryLearning.fit \"sklearn.decomposition.MiniBatchDictionaryLearning.fit\").\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_get_feature_names_out = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_get_feature_names_out = bridgeMiniBatchDictionaryLearning[${this.id}].get_feature_names_out(**pms_MiniBatchDictionaryLearning_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_get_feature_names_out.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_feature_names_out, 'tolist') else res_MiniBatchDictionaryLearning_get_feature_names_out`\n  }\n\n  /**\n    Update the model using the data in X as a mini-batch.\n   */\n  async partial_fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      The number of iteration on data batches that has been performed before this call to `partial\\_fit`. This is optional: if no number is passed, the memory of the object is used.\n     */\n    iter_offset?: number\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before partial_fit()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_partial_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'iter_offset': ${opts['iter_offset'] ?? undefined}}\n\npms_MiniBatchDictionaryLearning_partial_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_partial_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_partial_fit = bridgeMiniBatchDictionaryLearning[${this.id}].partial_fit(**pms_MiniBatchDictionaryLearning_partial_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_partial_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_partial_fit, 'tolist') else res_MiniBatchDictionaryLearning_partial_fit`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before set_output()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_MiniBatchDictionaryLearning_set_output = {k: v for k, v in pms_MiniBatchDictionaryLearning_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_set_output = bridgeMiniBatchDictionaryLearning[${this.id}].set_output(**pms_MiniBatchDictionaryLearning_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_set_output.tolist() if hasattr(res_MiniBatchDictionaryLearning_set_output, 'tolist') else res_MiniBatchDictionaryLearning_set_output`\n  }\n\n  /**\n    Encode the data as a sparse combination of the dictionary atoms.\n\n    Coding method is determined by the object parameter `transform\\_algorithm`.\n   */\n  async transform(opts: {\n    /**\n      Test data to be transformed, must have the same number of features as the data used to train the model.\n     */\n    X?: NDArray[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_MiniBatchDictionaryLearning_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_MiniBatchDictionaryLearning_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_MiniBatchDictionaryLearning_transform = bridgeMiniBatchDictionaryLearning[${this.id}].transform(**pms_MiniBatchDictionaryLearning_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_MiniBatchDictionaryLearning_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_transform, 'tolist') else res_MiniBatchDictionaryLearning_transform`\n  }\n\n  /**\n    Components extracted from the data.\n   */\n  get components_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing components_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_components_ = bridgeMiniBatchDictionaryLearning[${this.id}].components_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_components_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_components_, 'tolist') else attr_MiniBatchDictionaryLearning_components_`\n    })()\n  }\n\n  /**\n    Internal sufficient statistics that are kept by the algorithm. Keeping them is useful in online settings, to avoid losing the history of the evolution, but they shouldn’t have any use for the end user. `A` `(n\\_components, n\\_components)` is the dictionary covariance matrix. `B` `(n\\_features, n\\_components)` is the data approximation matrix.\n   */\n  get inner_stats_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing inner_stats_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_inner_stats_ = bridgeMiniBatchDictionaryLearning[${this.id}].inner_stats_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_inner_stats_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_inner_stats_, 'tolist') else attr_MiniBatchDictionaryLearning_inner_stats_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_n_features_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_n_features_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_features_in_, 'tolist') else attr_MiniBatchDictionaryLearning_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_feature_names_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_feature_names_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_feature_names_in_, 'tolist') else attr_MiniBatchDictionaryLearning_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations over the full dataset.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_n_iter_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_n_iter_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_iter_, 'tolist') else attr_MiniBatchDictionaryLearning_n_iter_`\n    })()\n  }\n\n  /**\n    The number of iteration on data batches that has been performed before.\n   */\n  get iter_offset_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing iter_offset_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_iter_offset_ = bridgeMiniBatchDictionaryLearning[${this.id}].iter_offset_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_iter_offset_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_iter_offset_, 'tolist') else attr_MiniBatchDictionaryLearning_iter_offset_`\n    })()\n  }\n\n  /**\n    RandomState instance that is generated either from a seed, the random number generattor or by `np.random`.\n   */\n  get random_state_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing random_state_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_random_state_ = bridgeMiniBatchDictionaryLearning[${this.id}].random_state_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_random_state_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_random_state_, 'tolist') else attr_MiniBatchDictionaryLearning_random_state_`\n    })()\n  }\n\n  /**\n    Number of mini-batches processed.\n   */\n  get n_steps_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This MiniBatchDictionaryLearning instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'MiniBatchDictionaryLearning must call init() before accessing n_steps_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_MiniBatchDictionaryLearning_n_steps_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_steps_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_MiniBatchDictionaryLearning_n_steps_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_steps_, 'tolist') else attr_MiniBatchDictionaryLearning_n_steps_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}