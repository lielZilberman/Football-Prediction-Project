{"version":3,"sources":["../../../src/generated/decomposition/KernelPCA.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Kernel Principal component analysis (KPCA) [\\[1\\]](#r396fc7d924b8-1).\n\n  Non-linear dimensionality reduction through the use of kernels (see [Pairwise metrics, Affinities and Kernels](../metrics.html#metrics)).\n\n  It uses the [`scipy.linalg.eigh`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigh.html#scipy.linalg.eigh \"(in SciPy v1.10.1)\") LAPACK implementation of the full SVD or the [`scipy.sparse.linalg.eigsh`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh \"(in SciPy v1.10.1)\") ARPACK implementation of the truncated SVD, depending on the shape of the input data and the number of components to extract. It can also use a randomized truncated SVD by the method proposed in [\\[3\\]](#r396fc7d924b8-3), see `eigen\\_solver`.\n\n  Read more in the [User Guide](../decomposition.html#kernel-pca).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html)\n */\nexport class KernelPCA {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Number of components. If `undefined`, all non-zero components are kept.\n     */\n    n_components?: number\n\n    /**\n      Kernel used for PCA.\n\n      @defaultValue `'linear'`\n     */\n    kernel?: 'linear' | 'poly' | 'rbf' | 'sigmoid' | 'cosine' | 'precomputed'\n\n    /**\n      Kernel coefficient for rbf, poly and sigmoid kernels. Ignored by other kernels. If `gamma` is `undefined`, then it is set to `1/n\\_features`.\n     */\n    gamma?: number\n\n    /**\n      Degree for poly kernels. Ignored by other kernels.\n\n      @defaultValue `3`\n     */\n    degree?: number\n\n    /**\n      Independent term in poly and sigmoid kernels. Ignored by other kernels.\n\n      @defaultValue `1`\n     */\n    coef0?: number\n\n    /**\n      Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels.\n     */\n    kernel_params?: any\n\n    /**\n      Hyperparameter of the ridge regression that learns the inverse transform (when fit\\_inverse\\_transform=`true`).\n\n      @defaultValue `1`\n     */\n    alpha?: number\n\n    /**\n      Learn the inverse transform for non-precomputed kernels (i.e. learn to find the pre-image of a point). This method is based on [\\[2\\]](#r396fc7d924b8-2).\n\n      @defaultValue `false`\n     */\n    fit_inverse_transform?: boolean\n\n    /**\n      Select eigensolver to use. If `n\\_components` is much less than the number of training samples, randomized (or arpack to a smaller extent) may be more efficient than the dense eigensolver. Randomized SVD is performed according to the method of Halko et al [\\[3\\]](#r396fc7d924b8-3).\n\n      @defaultValue `'auto'`\n     */\n    eigen_solver?: 'auto' | 'dense' | 'arpack' | 'randomized'\n\n    /**\n      Convergence tolerance for arpack. If 0, optimal value will be chosen by arpack.\n\n      @defaultValue `0`\n     */\n    tol?: number\n\n    /**\n      Maximum number of iterations for arpack. If `undefined`, optimal value will be chosen by arpack.\n     */\n    max_iter?: number\n\n    /**\n      Number of iterations for the power method computed by svd\\_solver == ‘randomized’. When ‘auto’, it is set to 7 when `n\\_components < 0.1 \\* min(X.shape)`, other it is set to 4.\n\n      @defaultValue `'auto'`\n     */\n    iterated_power?: 'auto'\n\n    /**\n      If `true`, then all components with zero eigenvalues are removed, so that the number of components in the output may be < n\\_components (and sometimes even zero due to numerical instability). When n\\_components is `undefined`, this parameter is ignored and components with zero eigenvalues are removed regardless.\n\n      @defaultValue `false`\n     */\n    remove_zero_eig?: boolean\n\n    /**\n      Used when `eigen\\_solver` == ‘arpack’ or ‘randomized’. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).\n     */\n    random_state?: number\n\n    /**\n      If `true`, input X is copied and stored by the model in the `X\\_fit\\_` attribute. If no further changes will be done to X, setting `copy\\_X=False` saves memory by storing a reference.\n\n      @defaultValue `true`\n     */\n    copy_X?: boolean\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend \"(in joblib v1.3.0.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `KernelPCA${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('KernelPCA.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.decomposition import KernelPCA\ntry: bridgeKernelPCA\nexcept NameError: bridgeKernelPCA = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_KernelPCA = {'n_components': ${\n      this.opts['n_components'] ?? undefined\n    }, 'kernel': ${this.opts['kernel'] ?? undefined}, 'gamma': ${\n      this.opts['gamma'] ?? undefined\n    }, 'degree': ${this.opts['degree'] ?? undefined}, 'coef0': ${\n      this.opts['coef0'] ?? undefined\n    }, 'kernel_params': ${this.opts['kernel_params'] ?? undefined}, 'alpha': ${\n      this.opts['alpha'] ?? undefined\n    }, 'fit_inverse_transform': ${\n      this.opts['fit_inverse_transform'] ?? undefined\n    }, 'eigen_solver': ${this.opts['eigen_solver'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'iterated_power': ${\n      this.opts['iterated_power'] ?? undefined\n    }, 'remove_zero_eig': ${\n      this.opts['remove_zero_eig'] ?? undefined\n    }, 'random_state': ${this.opts['random_state'] ?? undefined}, 'copy_X': ${\n      this.opts['copy_X'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_KernelPCA = {k: v for k, v in ctor_KernelPCA.items() if v is not None}`\n\n    await this._py.ex`bridgeKernelPCA[${this.id}] = KernelPCA(**ctor_KernelPCA)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeKernelPCA[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model from data in X.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${opts['y'] ?? undefined}}\n\npms_KernelPCA_fit = {k: v for k, v in pms_KernelPCA_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_fit = bridgeKernelPCA[${this.id}].fit(**pms_KernelPCA_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_fit.tolist() if hasattr(res_KernelPCA_fit, 'tolist') else res_KernelPCA_fit`\n  }\n\n  /**\n    Fit the model from data in X and transform X.\n   */\n  async fit_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Not used, present for API consistency by convention.\n     */\n    y?: any\n\n    /**\n      Parameters (keyword arguments) and values passed to the fit\\_transform instance.\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_fit_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': ${\n      opts['y'] ?? undefined\n    }, 'params': ${opts['params'] ?? undefined}}\n\npms_KernelPCA_fit_transform = {k: v for k, v in pms_KernelPCA_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_fit_transform = bridgeKernelPCA[${this.id}].fit_transform(**pms_KernelPCA_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_fit_transform.tolist() if hasattr(res_KernelPCA_fit_transform, 'tolist') else res_KernelPCA_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\\[\"class\\_name0\", \"class\\_name1\", \"class\\_name2\"\\]`.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Only used to validate feature names with the names seen in [`fit`](#sklearn.decomposition.KernelPCA.fit \"sklearn.decomposition.KernelPCA.fit\").\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_KernelPCA_get_feature_names_out = {'input_features': ${\n      opts['input_features'] ?? undefined\n    }}\n\npms_KernelPCA_get_feature_names_out = {k: v for k, v in pms_KernelPCA_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_get_feature_names_out = bridgeKernelPCA[${this.id}].get_feature_names_out(**pms_KernelPCA_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_get_feature_names_out.tolist() if hasattr(res_KernelPCA_get_feature_names_out, 'tolist') else res_KernelPCA_get_feature_names_out`\n  }\n\n  /**\n    Transform X back to original space.\n\n    `inverse\\_transform` approximates the inverse transformation using a learned pre-image. The pre-image is learned by kernel ridge regression of the original data on their low-dimensional representation vectors.\n   */\n  async inverse_transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_inverse_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KernelPCA_inverse_transform = {k: v for k, v in pms_KernelPCA_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_inverse_transform = bridgeKernelPCA[${this.id}].inverse_transform(**pms_KernelPCA_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_inverse_transform.tolist() if hasattr(res_KernelPCA_inverse_transform, 'tolist') else res_KernelPCA_inverse_transform`\n  }\n\n  /**\n    Set output container.\n\n    See [Introducing the set\\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit\\_transform`.\n     */\n    transform?: 'default' | 'pandas'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_set_output = {'transform': ${\n      opts['transform'] ?? undefined\n    }}\n\npms_KernelPCA_set_output = {k: v for k, v in pms_KernelPCA_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_set_output = bridgeKernelPCA[${this.id}].set_output(**pms_KernelPCA_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_set_output.tolist() if hasattr(res_KernelPCA_set_output, 'tolist') else res_KernelPCA_set_output`\n  }\n\n  /**\n    Transform X.\n   */\n  async transform(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_KernelPCA_transform = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_KernelPCA_transform = {k: v for k, v in pms_KernelPCA_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_KernelPCA_transform = bridgeKernelPCA[${this.id}].transform(**pms_KernelPCA_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_KernelPCA_transform.tolist() if hasattr(res_KernelPCA_transform, 'tolist') else res_KernelPCA_transform`\n  }\n\n  /**\n    Eigenvalues of the centered kernel matrix in decreasing order. If `n\\_components` and `remove\\_zero\\_eig` are not set, then all values are stored.\n   */\n  get eigenvalues_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing eigenvalues_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_eigenvalues_ = bridgeKernelPCA[${this.id}].eigenvalues_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_eigenvalues_.tolist() if hasattr(attr_KernelPCA_eigenvalues_, 'tolist') else attr_KernelPCA_eigenvalues_`\n    })()\n  }\n\n  /**\n    Eigenvectors of the centered kernel matrix. If `n\\_components` and `remove\\_zero\\_eig` are not set, then all components are stored.\n   */\n  get eigenvectors_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing eigenvectors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_eigenvectors_ = bridgeKernelPCA[${this.id}].eigenvectors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_eigenvectors_.tolist() if hasattr(attr_KernelPCA_eigenvectors_, 'tolist') else attr_KernelPCA_eigenvectors_`\n    })()\n  }\n\n  /**\n    Inverse transform matrix. Only available when `fit\\_inverse\\_transform` is `true`.\n   */\n  get dual_coef_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before accessing dual_coef_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_dual_coef_ = bridgeKernelPCA[${this.id}].dual_coef_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_dual_coef_.tolist() if hasattr(attr_KernelPCA_dual_coef_, 'tolist') else attr_KernelPCA_dual_coef_`\n    })()\n  }\n\n  /**\n    Projection of the fitted data on the kernel principal components. Only available when `fit\\_inverse\\_transform` is `true`.\n   */\n  get X_transformed_fit_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing X_transformed_fit_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_X_transformed_fit_ = bridgeKernelPCA[${this.id}].X_transformed_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_X_transformed_fit_.tolist() if hasattr(attr_KernelPCA_X_transformed_fit_, 'tolist') else attr_KernelPCA_X_transformed_fit_`\n    })()\n  }\n\n  /**\n    The data used to fit the model. If `copy\\_X=False`, then `X\\_fit\\_` is a reference. This attribute is used for the calls to transform.\n   */\n  get X_fit_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('KernelPCA must call init() before accessing X_fit_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_X_fit_ = bridgeKernelPCA[${this.id}].X_fit_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_X_fit_.tolist() if hasattr(attr_KernelPCA_X_fit_, 'tolist') else attr_KernelPCA_X_fit_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_n_features_in_ = bridgeKernelPCA[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_n_features_in_.tolist() if hasattr(attr_KernelPCA_n_features_in_, 'tolist') else attr_KernelPCA_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This KernelPCA instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'KernelPCA must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_KernelPCA_feature_names_in_ = bridgeKernelPCA[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_KernelPCA_feature_names_in_.tolist() if hasattr(attr_KernelPCA_feature_names_in_, 'tolist') else attr_KernelPCA_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}