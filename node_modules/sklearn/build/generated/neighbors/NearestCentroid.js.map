{"version":3,"sources":["../../../src/generated/neighbors/NearestCentroid.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Nearest centroid classifier.\n\n  Each class is represented by its centroid, with test samples classified to the class with the nearest centroid.\n\n  Read more in the [User Guide](../neighbors.html#nearest-centroid-classifier).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestCentroid.html)\n */\nexport class NearestCentroid {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Metric to use for distance computation. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics \"sklearn.metrics.pairwise.distance_metrics\") for valid metric values. Note that “wminkowski”, “seuclidean” and “mahalanobis” are not supported.\n\n      The centroids for the samples corresponding to each class is the point from which the sum of the distances (according to the metric) of all samples that belong to that particular class are minimized. If the `\"manhattan\"` metric is provided, this centroid is the median and for all other metrics, the centroid is now set to be the mean.\n\n      @defaultValue `'euclidean'`\n     */\n    metric?: string\n\n    /**\n      Threshold for shrinking centroids to remove features.\n     */\n    shrink_threshold?: number\n  }) {\n    this.id = `NearestCentroid${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('NearestCentroid.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.neighbors import NearestCentroid\ntry: bridgeNearestCentroid\nexcept NameError: bridgeNearestCentroid = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_NearestCentroid = {'metric': ${\n      this.opts['metric'] ?? undefined\n    }, 'shrink_threshold': ${this.opts['shrink_threshold'] ?? undefined}}\n\nctor_NearestCentroid = {k: v for k, v in ctor_NearestCentroid.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeNearestCentroid[${this.id}] = NearestCentroid(**ctor_NearestCentroid)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeNearestCentroid[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the NearestCentroid model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features. Note that centroid shrinking cannot be used with sparse matrices.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestCentroid must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_NearestCentroid_fit = {k: v for k, v in pms_NearestCentroid_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_fit = bridgeNearestCentroid[${this.id}].fit(**pms_NearestCentroid_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_fit.tolist() if hasattr(res_NearestCentroid_fit, 'tolist') else res_NearestCentroid_fit`\n  }\n\n  /**\n    Perform classification on an array of test vectors `X`.\n\n    The predicted class `C` for each sample in `X` is returned.\n   */\n  async predict(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestCentroid must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_NearestCentroid_predict = {k: v for k, v in pms_NearestCentroid_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_predict = bridgeNearestCentroid[${this.id}].predict(**pms_NearestCentroid_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_predict.tolist() if hasattr(res_NearestCentroid_predict, 'tolist') else res_NearestCentroid_predict`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('NearestCentroid must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_NearestCentroid_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_NearestCentroid_score = {k: v for k, v in pms_NearestCentroid_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_NearestCentroid_score = bridgeNearestCentroid[${this.id}].score(**pms_NearestCentroid_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_NearestCentroid_score.tolist() if hasattr(res_NearestCentroid_score, 'tolist') else res_NearestCentroid_score`\n  }\n\n  /**\n    Centroid of each class.\n   */\n  get centroids_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing centroids_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_centroids_ = bridgeNearestCentroid[${this.id}].centroids_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_centroids_.tolist() if hasattr(attr_NearestCentroid_centroids_, 'tolist') else attr_NearestCentroid_centroids_`\n    })()\n  }\n\n  /**\n    The unique classes labels.\n   */\n  get classes_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_classes_ = bridgeNearestCentroid[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_classes_.tolist() if hasattr(attr_NearestCentroid_classes_, 'tolist') else attr_NearestCentroid_classes_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_n_features_in_ = bridgeNearestCentroid[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_n_features_in_.tolist() if hasattr(attr_NearestCentroid_n_features_in_, 'tolist') else attr_NearestCentroid_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This NearestCentroid instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'NearestCentroid must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_NearestCentroid_feature_names_in_ = bridgeNearestCentroid[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_NearestCentroid_feature_names_in_.tolist() if hasattr(attr_NearestCentroid_feature_names_in_, 'tolist') else attr_NearestCentroid_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}