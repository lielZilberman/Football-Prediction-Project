import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Kernel Density Estimation.

  Read more in the [User Guide](../density.html#kernel-density).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KernelDensity.html)
 */
export declare class KernelDensity {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          The bandwidth of the kernel. If bandwidth is a float, it defines the bandwidth of the kernel. If bandwidth is a string, one of the estimation methods is implemented.
    
          @defaultValue `1`
         */
        bandwidth?: number | 'scott' | 'silverman';
        /**
          The tree algorithm to use.
    
          @defaultValue `'auto'`
         */
        algorithm?: 'kd_tree' | 'ball_tree' | 'auto';
        /**
          The kernel to use.
    
          @defaultValue `'gaussian'`
         */
        kernel?: 'gaussian' | 'tophat' | 'epanechnikov' | 'exponential' | 'linear' | 'cosine';
        /**
          Metric to use for distance computation. See the documentation of [scipy.spatial.distance](https://docs.scipy.org/doc/scipy/reference/spatial.distance.html) and the metrics listed in [`distance\_metrics`](sklearn.metrics.pairwise.distance_metrics.html#sklearn.metrics.pairwise.distance_metrics "sklearn.metrics.pairwise.distance_metrics") for valid metric values.
    
          Not all metrics are valid with all algorithms: refer to the documentation of [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree "sklearn.neighbors.BallTree") and [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree "sklearn.neighbors.KDTree"). Note that the normalization of the density output is correct only for the Euclidean distance metric.
    
          @defaultValue `'euclidean'`
         */
        metric?: string;
        /**
          The desired absolute tolerance of the result. A larger tolerance will generally lead to faster execution.
    
          @defaultValue `0`
         */
        atol?: number;
        /**
          The desired relative tolerance of the result. A larger tolerance will generally lead to faster execution.
    
          @defaultValue `0`
         */
        rtol?: number;
        /**
          If true (default), use a breadth-first approach to the problem. Otherwise use a depth-first approach.
    
          @defaultValue `true`
         */
        breadth_first?: boolean;
        /**
          Specify the leaf size of the underlying tree. See [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree "sklearn.neighbors.BallTree") or [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree "sklearn.neighbors.KDTree") for details.
    
          @defaultValue `40`
         */
        leaf_size?: number;
        /**
          Additional parameters to be passed to the tree for use with the metric. For more information, see the documentation of [`BallTree`](sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree "sklearn.neighbors.BallTree") or [`KDTree`](sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree "sklearn.neighbors.KDTree").
         */
        metric_params?: any;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the Kernel Density model on the data.
     */
    fit(opts: {
        /**
          List of n\_features-dimensional data points. Each row corresponds to a single data point.
         */
        X?: ArrayLike[];
        /**
          Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline "sklearn.pipeline.Pipeline").
         */
        y?: any;
        /**
          List of sample weights attached to the data X.
         */
        sample_weight?: ArrayLike;
    }): Promise<any>;
    /**
      Generate random samples from the model.
  
      Currently, this is implemented only for gaussian and tophat kernels.
     */
    sample(opts: {
        /**
          Number of samples to generate.
    
          @defaultValue `1`
         */
        n_samples?: number;
        /**
          Determines random number generation used to generate random samples. Pass an int for reproducible results across multiple function calls. See [Glossary](../../glossary.html#term-random_state).
         */
        random_state?: number;
    }): Promise<ArrayLike[]>;
    /**
      Compute the total log-likelihood under the model.
     */
    score(opts: {
        /**
          List of n\_features-dimensional data points. Each row corresponds to a single data point.
         */
        X?: ArrayLike[];
        /**
          Ignored. This parameter exists only for compatibility with [`Pipeline`](sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline "sklearn.pipeline.Pipeline").
         */
        y?: any;
    }): Promise<number>;
    /**
      Compute the log-likelihood of each sample under the model.
     */
    score_samples(opts: {
        /**
          An array of points to query. Last dimension should match dimension of training data (n\_features).
         */
        X?: ArrayLike[];
    }): Promise<NDArray>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      The tree algorithm for fast generalized N-point problems.
     */
    get tree_(): Promise<any>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
    /**
      Value of the bandwidth, given directly by the bandwidth parameter or estimated using the ‘scott’ or ‘silverman’ method.
     */
    get bandwidth_(): Promise<number>;
}
//# sourceMappingURL=KernelDensity.d.ts.map