{"version":3,"sources":["../../../src/generated/semi_supervised/LabelPropagation.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Label Propagation classifier.\n\n  Read more in the [User Guide](../semi_supervised.html#label-propagation).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.semi_supervised.LabelPropagation.html)\n */\nexport class LabelPropagation {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      String identifier for kernel function to use or the kernel function itself. Only ‘rbf’ and ‘knn’ strings are valid inputs. The function passed should take two inputs, each of shape (n\\_samples, n\\_features), and return a (n\\_samples, n\\_samples) shaped weight matrix.\n\n      @defaultValue `'rbf'`\n     */\n    kernel?: 'knn' | 'rbf'\n\n    /**\n      Parameter for rbf kernel.\n\n      @defaultValue `20`\n     */\n    gamma?: number\n\n    /**\n      Parameter for knn kernel which need to be strictly positive.\n\n      @defaultValue `7`\n     */\n    n_neighbors?: number\n\n    /**\n      Change maximum number of iterations allowed.\n\n      @defaultValue `1000`\n     */\n    max_iter?: number\n\n    /**\n      Convergence tolerance: threshold to consider the system at steady state.\n     */\n    tol?: number\n\n    /**\n      The number of parallel jobs to run. `undefined` means 1 unless in a [`joblib.parallel\\_backend`](https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend \"(in joblib v1.3.0.dev0)\") context. `\\-1` means using all processors. See [Glossary](../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n  }) {\n    this.id = `LabelPropagation${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('LabelPropagation.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.semi_supervised import LabelPropagation\ntry: bridgeLabelPropagation\nexcept NameError: bridgeLabelPropagation = {}\n`\n\n    // set up constructor params\n    await this._py.ex`ctor_LabelPropagation = {'kernel': ${\n      this.opts['kernel'] ?? undefined\n    }, 'gamma': ${this.opts['gamma'] ?? undefined}, 'n_neighbors': ${\n      this.opts['n_neighbors'] ?? undefined\n    }, 'max_iter': ${this.opts['max_iter'] ?? undefined}, 'tol': ${\n      this.opts['tol'] ?? undefined\n    }, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}}\n\nctor_LabelPropagation = {k: v for k, v in ctor_LabelPropagation.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeLabelPropagation[${this.id}] = LabelPropagation(**ctor_LabelPropagation)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeLabelPropagation[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit a semi-supervised label propagation model to X.\n   */\n  async fit(opts: {\n    /**\n      Training data, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target class values with unlabeled points marked as -1. All unlabeled samples will be transductively assigned labels internally, which are stored in `transduction\\_`.\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_LabelPropagation_fit = {k: v for k, v in pms_LabelPropagation_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_fit = bridgeLabelPropagation[${this.id}].fit(**pms_LabelPropagation_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_fit.tolist() if hasattr(res_LabelPropagation_fit, 'tolist') else res_LabelPropagation_fit`\n  }\n\n  /**\n    Perform inductive inference across the model.\n   */\n  async predict(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelPropagation_predict = {k: v for k, v in pms_LabelPropagation_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_predict = bridgeLabelPropagation[${this.id}].predict(**pms_LabelPropagation_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_predict.tolist() if hasattr(res_LabelPropagation_predict, 'tolist') else res_LabelPropagation_predict`\n  }\n\n  /**\n    Predict probability for each possible outcome.\n\n    Compute the probability estimates for each single sample in X and each possible outcome seen during training (categorical distribution).\n   */\n  async predict_proba(opts: {\n    /**\n      The data matrix.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_LabelPropagation_predict_proba = {k: v for k, v in pms_LabelPropagation_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_predict_proba = bridgeLabelPropagation[${this.id}].predict_proba(**pms_LabelPropagation_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_predict_proba.tolist() if hasattr(res_LabelPropagation_predict_proba, 'tolist') else res_LabelPropagation_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before score()')\n    }\n\n    // set up method params\n    await this._py.ex`pms_LabelPropagation_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_LabelPropagation_score = {k: v for k, v in pms_LabelPropagation_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_LabelPropagation_score = bridgeLabelPropagation[${this.id}].score(**pms_LabelPropagation_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_LabelPropagation_score.tolist() if hasattr(res_LabelPropagation_score, 'tolist') else res_LabelPropagation_score`\n  }\n\n  /**\n    Input array.\n   */\n  get X_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('LabelPropagation must call init() before accessing X_')\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_X_ = bridgeLabelPropagation[${this.id}].X_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_X_.tolist() if hasattr(attr_LabelPropagation_X_, 'tolist') else attr_LabelPropagation_X_`\n    })()\n  }\n\n  /**\n    The distinct labels used in classifying instances.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_classes_ = bridgeLabelPropagation[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_classes_.tolist() if hasattr(attr_LabelPropagation_classes_, 'tolist') else attr_LabelPropagation_classes_`\n    })()\n  }\n\n  /**\n    Categorical distribution for each item.\n   */\n  get label_distributions_(): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing label_distributions_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_label_distributions_ = bridgeLabelPropagation[${this.id}].label_distributions_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_label_distributions_.tolist() if hasattr(attr_LabelPropagation_label_distributions_, 'tolist') else attr_LabelPropagation_label_distributions_`\n    })()\n  }\n\n  /**\n    Label assigned to each item during [fit](../../glossary.html#term-fit).\n   */\n  get transduction_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing transduction_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_transduction_ = bridgeLabelPropagation[${this.id}].transduction_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_transduction_.tolist() if hasattr(attr_LabelPropagation_transduction_, 'tolist') else attr_LabelPropagation_transduction_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_n_features_in_ = bridgeLabelPropagation[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_n_features_in_.tolist() if hasattr(attr_LabelPropagation_n_features_in_, 'tolist') else attr_LabelPropagation_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_feature_names_in_ = bridgeLabelPropagation[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_feature_names_in_.tolist() if hasattr(attr_LabelPropagation_feature_names_in_, 'tolist') else attr_LabelPropagation_feature_names_in_`\n    })()\n  }\n\n  /**\n    Number of iterations run.\n   */\n  get n_iter_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This LabelPropagation instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'LabelPropagation must call init() before accessing n_iter_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_LabelPropagation_n_iter_ = bridgeLabelPropagation[${this.id}].n_iter_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_LabelPropagation_n_iter_.tolist() if hasattr(attr_LabelPropagation_n_iter_, 'tolist') else attr_LabelPropagation_n_iter_`\n    })()\n  }\n}\n"],"mappings":"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","names":[]}