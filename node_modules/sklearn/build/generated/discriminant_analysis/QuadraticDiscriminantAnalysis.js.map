{"version":3,"sources":["../../../src/generated/discriminant_analysis/QuadraticDiscriminantAnalysis.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Quadratic Discriminant Analysis.\n\n  A classifier with a quadratic decision boundary, generated by fitting class conditional densities to the data and using Bayesâ€™ rule.\n\n  The model fits a Gaussian density to each class.\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis.html)\n */\nexport class QuadraticDiscriminantAnalysis {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Class priors. By default, the class proportions are inferred from the training data.\n     */\n    priors?: ArrayLike\n\n    /**\n      Regularizes the per-class covariance estimates by transforming S2 as `S2 \\= (1 \\- reg\\_param) \\* S2 + reg\\_param \\* np.eye(n\\_features)`, where S2 corresponds to the `scaling\\_` attribute of a given class.\n\n      @defaultValue `0`\n     */\n    reg_param?: number\n\n    /**\n      If `true`, the class covariance matrices are explicitly computed and stored in the `self.covariance\\_` attribute.\n\n      @defaultValue `false`\n     */\n    store_covariance?: boolean\n\n    /**\n      Absolute threshold for a singular value to be considered significant, used to estimate the rank of `Xk` where `Xk` is the centered matrix of samples in class k. This parameter does not affect the predictions. It only controls a warning that is raised when features are considered to be colinear.\n\n      @defaultValue `0.0001`\n     */\n    tol?: number\n  }) {\n    this.id = `QuadraticDiscriminantAnalysis${\n      crypto.randomUUID().split('-')[0]\n    }`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\ntry: bridgeQuadraticDiscriminantAnalysis\nexcept NameError: bridgeQuadraticDiscriminantAnalysis = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_QuadraticDiscriminantAnalysis = {'priors': np.array(${\n      this.opts['priors'] ?? undefined\n    }) if ${this.opts['priors'] !== undefined} else None, 'reg_param': ${\n      this.opts['reg_param'] ?? undefined\n    }, 'store_covariance': ${\n      this.opts['store_covariance'] ?? undefined\n    }, 'tol': ${this.opts['tol'] ?? undefined}}\n\nctor_QuadraticDiscriminantAnalysis = {k: v for k, v in ctor_QuadraticDiscriminantAnalysis.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeQuadraticDiscriminantAnalysis[${this.id}] = QuadraticDiscriminantAnalysis(**ctor_QuadraticDiscriminantAnalysis)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeQuadraticDiscriminantAnalysis[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Apply decision function to an array of samples.\n\n    The decision function is equal (up to a constant factor) to the log-posterior of the model, i.e. `log p(y \\= k | x)`. In a binary classification setting this instead corresponds to the difference `log p(y \\= 1 | x) \\- log p(y \\= 0 | x)`. See [Mathematical formulation of the LDA and QDA classifiers](../lda_qda.html#lda-qda-math).\n   */\n  async decision_function(opts: {\n    /**\n      Array of samples (test vectors).\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before decision_function()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuadraticDiscriminantAnalysis_decision_function = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_QuadraticDiscriminantAnalysis_decision_function = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuadraticDiscriminantAnalysis_decision_function = bridgeQuadraticDiscriminantAnalysis[${this.id}].decision_function(**pms_QuadraticDiscriminantAnalysis_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuadraticDiscriminantAnalysis_decision_function.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_decision_function, 'tolist') else res_QuadraticDiscriminantAnalysis_decision_function`\n  }\n\n  /**\n    Fit the model according to the given training data and parameters.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values (integers).\n     */\n    y?: ArrayLike\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_QuadraticDiscriminantAnalysis_fit = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None}\n\npms_QuadraticDiscriminantAnalysis_fit = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuadraticDiscriminantAnalysis_fit = bridgeQuadraticDiscriminantAnalysis[${this.id}].fit(**pms_QuadraticDiscriminantAnalysis_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuadraticDiscriminantAnalysis_fit.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_fit, 'tolist') else res_QuadraticDiscriminantAnalysis_fit`\n  }\n\n  /**\n    Perform classification on an array of test vectors X.\n\n    The predicted class C for each sample in X is returned.\n   */\n  async predict(opts: {\n    /**\n      Vector to be scored, where `n\\_samples` is the number of samples and `n\\_features` is the number of features.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuadraticDiscriminantAnalysis_predict = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_QuadraticDiscriminantAnalysis_predict = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuadraticDiscriminantAnalysis_predict = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict(**pms_QuadraticDiscriminantAnalysis_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuadraticDiscriminantAnalysis_predict.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict, 'tolist') else res_QuadraticDiscriminantAnalysis_predict`\n  }\n\n  /**\n    Return log of posterior probabilities of classification.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Array of samples/test vectors.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before predict_log_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuadraticDiscriminantAnalysis_predict_log_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_QuadraticDiscriminantAnalysis_predict_log_proba = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuadraticDiscriminantAnalysis_predict_log_proba = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict_log_proba(**pms_QuadraticDiscriminantAnalysis_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuadraticDiscriminantAnalysis_predict_log_proba.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict_log_proba, 'tolist') else res_QuadraticDiscriminantAnalysis_predict_log_proba`\n  }\n\n  /**\n    Return posterior probabilities of classification.\n   */\n  async predict_proba(opts: {\n    /**\n      Array of samples/test vectors.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuadraticDiscriminantAnalysis_predict_proba = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None}\n\npms_QuadraticDiscriminantAnalysis_predict_proba = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuadraticDiscriminantAnalysis_predict_proba = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict_proba(**pms_QuadraticDiscriminantAnalysis_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuadraticDiscriminantAnalysis_predict_proba.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict_proba, 'tolist') else res_QuadraticDiscriminantAnalysis_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_QuadraticDiscriminantAnalysis_score = {'X': np.array(${\n      opts['X'] ?? undefined\n    }) if ${opts['X'] !== undefined} else None, 'y': np.array(${\n      opts['y'] ?? undefined\n    }) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${\n      opts['sample_weight'] ?? undefined\n    }) if ${opts['sample_weight'] !== undefined} else None}\n\npms_QuadraticDiscriminantAnalysis_score = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_QuadraticDiscriminantAnalysis_score = bridgeQuadraticDiscriminantAnalysis[${this.id}].score(**pms_QuadraticDiscriminantAnalysis_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_QuadraticDiscriminantAnalysis_score.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_score, 'tolist') else res_QuadraticDiscriminantAnalysis_score`\n  }\n\n  /**\n    For each class, gives the covariance matrix estimated using the samples of that class. The estimations are unbiased. Only present if `store\\_covariance` is `true`.\n   */\n  get covariance_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing covariance_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_covariance_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].covariance_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_covariance_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_covariance_, 'tolist') else attr_QuadraticDiscriminantAnalysis_covariance_`\n    })()\n  }\n\n  /**\n    Class-wise means.\n   */\n  get means_(): Promise<ArrayLike[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing means_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_means_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].means_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_means_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_means_, 'tolist') else attr_QuadraticDiscriminantAnalysis_means_`\n    })()\n  }\n\n  /**\n    Class priors (sum to 1).\n   */\n  get priors_(): Promise<ArrayLike> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing priors_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_priors_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].priors_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_priors_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_priors_, 'tolist') else attr_QuadraticDiscriminantAnalysis_priors_`\n    })()\n  }\n\n  /**\n    For each class k an array of shape (n\\_features, n\\_k), where `n\\_k \\= min(n\\_features, number of elements in class k)` It is the rotation of the Gaussian distribution, i.e. its principal axis. It corresponds to `V`, the matrix of eigenvectors coming from the SVD of `Xk \\= U S Vt` where `Xk` is the centered matrix of samples from class k.\n   */\n  get rotations_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing rotations_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_rotations_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].rotations_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_rotations_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_rotations_, 'tolist') else attr_QuadraticDiscriminantAnalysis_rotations_`\n    })()\n  }\n\n  /**\n    For each class, contains the scaling of the Gaussian distributions along its principal axes, i.e. the variance in the rotated coordinate system. It corresponds to `S^2 / (n\\_samples \\- 1)`, where `S` is the diagonal matrix of singular values from the SVD of `Xk`, where `Xk` is the centered matrix of samples from class k.\n   */\n  get scalings_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing scalings_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_scalings_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].scalings_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_scalings_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_scalings_, 'tolist') else attr_QuadraticDiscriminantAnalysis_scalings_`\n    })()\n  }\n\n  /**\n    Unique class labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_classes_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_classes_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_classes_, 'tolist') else attr_QuadraticDiscriminantAnalysis_classes_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](../../glossary.html#term-fit).\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_n_features_in_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_n_features_in_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_n_features_in_, 'tolist') else attr_QuadraticDiscriminantAnalysis_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This QuadraticDiscriminantAnalysis instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'QuadraticDiscriminantAnalysis must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_QuadraticDiscriminantAnalysis_feature_names_in_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_QuadraticDiscriminantAnalysis_feature_names_in_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_feature_names_in_, 'tolist') else attr_QuadraticDiscriminantAnalysis_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":";AAGA,OAAO,YAAY;AAaZ,IAAM,gCAAN,MAAoC;AAAA,EAQzC,YAAY,MA0BT;AA7BH,0BAA0B;AAC1B,uBAAuB;AA6BrB,SAAK,KAAK,gCACR,OAAO,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAElC,SAAK,OAAO,QAAQ,CAAC;AAAA,EACvB;AAAA,EAEA,IAAI,KAAmB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,GAAG,cAA4B;AACjC,SAAK,MAAM;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KAAK,IAAiC;AAC1C,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,gBAAgB;AACvB;AAAA,IACF;AAEA,QAAI,CAAC,IAAI;AACP,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM;AAEX,UAAM,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,UAAM,KAAK,IACR,8DACD,KAAK,KAAK,QAAQ,KAAK,cACjB,KAAK,KAAK,QAAQ,MAAM,kCAC9B,KAAK,KAAK,WAAW,KAAK,+BAE1B,KAAK,KAAK,kBAAkB,KAAK,kBACvB,KAAK,KAAK,KAAK,KAAK;AAAA;AAAA;AAIhC,UAAM,KAAK,IACR,yCAAyC,KAAK;AAEjD,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAU;AACd,QAAI,KAAK,aAAa;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB;AAAA,IACF;AAEA,UAAM,KAAK,IAAI,6CAA6C,KAAK;AAEjE,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,kBAAkB,MAKH;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,0EACD,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,+FAA+F,KAAK;AAGvG,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,MAUO;AACf,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IAAI,4DACb,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,mCACpB,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,iFAAiF,KAAK;AAGzF,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,MAKO;AACnB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,gEACD,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,qFAAqF,KAAK;AAG7F,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,MAKD;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,0EACD,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,+FAA+F,KAAK;AAGvG,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,MAKG;AACrB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,sEACD,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM;AAAA;AAAA;AAKtB,UAAM,KAAK,IACR,2FAA2F,KAAK;AAGnG,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,MAAM,MAeQ;AAClB,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,UAAM,KAAK,IACR,8DACD,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,mCACpB,KAAK,GAAG,KAAK,cACP,KAAK,GAAG,MAAM,+CACpB,KAAK,eAAe,KAAK,cACnB,KAAK,eAAe,MAAM;AAAA;AAAA;AAKlC,UAAM,KAAK,IACR,mFAAmF,KAAK;AAG3F,WAAO,KACJ;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,cAA8B;AAChC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,0FAA0F,KAAK;AAGlG,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAA+B;AACjC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,qFAAqF,KAAK;AAG7F,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA8B;AAChC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,sFAAsF,KAAK;AAG9F,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,aAA6B;AAC/B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,yFAAyF,KAAK;AAGjG,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,YAA4B;AAC9B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,wFAAwF,KAAK;AAGhG,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAA6B;AAC/B,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,uFAAuF,KAAK;AAG/F,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAAkC;AACpC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,6FAA6F,KAAK;AAGrG,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,oBAAsC;AACxC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,gBAAgB;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,YAAY;AAElB,YAAM,KAAK,IACR,gGAAgG,KAAK;AAGxG,aAAO,KACJ;AAAA,IACL,GAAG;AAAA,EACL;AACF;","names":[]}