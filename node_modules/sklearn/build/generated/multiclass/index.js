// src/generated/multiclass/OneVsOneClassifier.ts
import crypto from "node:crypto";
var OneVsOneClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneVsOneClassifier${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OneVsOneClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multiclass import OneVsOneClassifier
try: bridgeOneVsOneClassifier
except NameError: bridgeOneVsOneClassifier = {}
`;
    await this._py.ex`ctor_OneVsOneClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OneVsOneClassifier = {k: v for k, v in ctor_OneVsOneClassifier.items() if v is not None}`;
    await this._py.ex`bridgeOneVsOneClassifier[${this.id}] = OneVsOneClassifier(**ctor_OneVsOneClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneVsOneClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Decision function for the OneVsOneClassifier.
  
      The decision values for the samples are computed by adding the normalized sum of pair-wise classification confidence levels to the votes in order to disambiguate between the decision values when the votes for all the classes are equal leading to a tie.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsOneClassifier_decision_function = {k: v for k, v in pms_OneVsOneClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_decision_function = bridgeOneVsOneClassifier[${this.id}].decision_function(**pms_OneVsOneClassifier_decision_function)`;
    return this._py`res_OneVsOneClassifier_decision_function.tolist() if hasattr(res_OneVsOneClassifier_decision_function, 'tolist') else res_OneVsOneClassifier_decision_function`;
  }
  /**
    Fit underlying estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsOneClassifier must call init() before fit()");
    }
    await this._py.ex`pms_OneVsOneClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OneVsOneClassifier_fit = {k: v for k, v in pms_OneVsOneClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_fit = bridgeOneVsOneClassifier[${this.id}].fit(**pms_OneVsOneClassifier_fit)`;
    return this._py`res_OneVsOneClassifier_fit.tolist() if hasattr(res_OneVsOneClassifier_fit, 'tolist') else res_OneVsOneClassifier_fit`;
  }
  /**
      Partially fit underlying estimators.
  
      Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration, where the first call should have an array of all target variables.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_OneVsOneClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': ${opts["classes"] ?? void 0}}

pms_OneVsOneClassifier_partial_fit = {k: v for k, v in pms_OneVsOneClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_partial_fit = bridgeOneVsOneClassifier[${this.id}].partial_fit(**pms_OneVsOneClassifier_partial_fit)`;
    return this._py`res_OneVsOneClassifier_partial_fit.tolist() if hasattr(res_OneVsOneClassifier_partial_fit, 'tolist') else res_OneVsOneClassifier_partial_fit`;
  }
  /**
      Estimate the best class label for each sample in X.
  
      This is implemented as `argmax(decision\_function(X), axis=1)` which will return the label of the class with most votes by estimators predicting the outcome of a decision for each possible class pair.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsOneClassifier must call init() before predict()");
    }
    await this._py.ex`pms_OneVsOneClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsOneClassifier_predict = {k: v for k, v in pms_OneVsOneClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_predict = bridgeOneVsOneClassifier[${this.id}].predict(**pms_OneVsOneClassifier_predict)`;
    return this._py`res_OneVsOneClassifier_predict.tolist() if hasattr(res_OneVsOneClassifier_predict, 'tolist') else res_OneVsOneClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsOneClassifier must call init() before score()");
    }
    await this._py.ex`pms_OneVsOneClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OneVsOneClassifier_score = {k: v for k, v in pms_OneVsOneClassifier_score.items() if v is not None}`;
    await this._py.ex`res_OneVsOneClassifier_score = bridgeOneVsOneClassifier[${this.id}].score(**pms_OneVsOneClassifier_score)`;
    return this._py`res_OneVsOneClassifier_score.tolist() if hasattr(res_OneVsOneClassifier_score, 'tolist') else res_OneVsOneClassifier_score`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_estimators_ = bridgeOneVsOneClassifier[${this.id}].estimators_`;
      return this._py`attr_OneVsOneClassifier_estimators_.tolist() if hasattr(attr_OneVsOneClassifier_estimators_, 'tolist') else attr_OneVsOneClassifier_estimators_`;
    })();
  }
  /**
    Array containing labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_classes_ = bridgeOneVsOneClassifier[${this.id}].classes_`;
      return this._py`attr_OneVsOneClassifier_classes_.tolist() if hasattr(attr_OneVsOneClassifier_classes_, 'tolist') else attr_OneVsOneClassifier_classes_`;
    })();
  }
  /**
    Indices of samples used when training the estimators. `undefined` when `estimator`â€™s `pairwise` tag is `false`.
   */
  get pairwise_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing pairwise_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_pairwise_indices_ = bridgeOneVsOneClassifier[${this.id}].pairwise_indices_`;
      return this._py`attr_OneVsOneClassifier_pairwise_indices_.tolist() if hasattr(attr_OneVsOneClassifier_pairwise_indices_, 'tolist') else attr_OneVsOneClassifier_pairwise_indices_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_n_features_in_ = bridgeOneVsOneClassifier[${this.id}].n_features_in_`;
      return this._py`attr_OneVsOneClassifier_n_features_in_.tolist() if hasattr(attr_OneVsOneClassifier_n_features_in_, 'tolist') else attr_OneVsOneClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsOneClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsOneClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsOneClassifier_feature_names_in_ = bridgeOneVsOneClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_OneVsOneClassifier_feature_names_in_.tolist() if hasattr(attr_OneVsOneClassifier_feature_names_in_, 'tolist') else attr_OneVsOneClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/multiclass/OneVsRestClassifier.ts
import crypto2 from "node:crypto";
var OneVsRestClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OneVsRestClassifier${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OneVsRestClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multiclass import OneVsRestClassifier
try: bridgeOneVsRestClassifier
except NameError: bridgeOneVsRestClassifier = {}
`;
    await this._py.ex`ctor_OneVsRestClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_OneVsRestClassifier = {k: v for k, v in ctor_OneVsRestClassifier.items() if v is not None}`;
    await this._py.ex`bridgeOneVsRestClassifier[${this.id}] = OneVsRestClassifier(**ctor_OneVsRestClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOneVsRestClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Decision function for the OneVsRestClassifier.
  
      Return the distance of each sample from the decision boundary for each class. This can only be used with estimators which implement the `decision\_function` method.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsRestClassifier_decision_function = {k: v for k, v in pms_OneVsRestClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_decision_function = bridgeOneVsRestClassifier[${this.id}].decision_function(**pms_OneVsRestClassifier_decision_function)`;
    return this._py`res_OneVsRestClassifier_decision_function.tolist() if hasattr(res_OneVsRestClassifier_decision_function, 'tolist') else res_OneVsRestClassifier_decision_function`;
  }
  /**
    Fit underlying estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsRestClassifier must call init() before fit()");
    }
    await this._py.ex`pms_OneVsRestClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OneVsRestClassifier_fit = {k: v for k, v in pms_OneVsRestClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_fit = bridgeOneVsRestClassifier[${this.id}].fit(**pms_OneVsRestClassifier_fit)`;
    return this._py`res_OneVsRestClassifier_fit.tolist() if hasattr(res_OneVsRestClassifier_fit, 'tolist') else res_OneVsRestClassifier_fit`;
  }
  /**
      Partially fit underlying estimators.
  
      Should be used when memory is inefficient to train all data. Chunks of data can be passed in several iteration.
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'classes': ${opts["classes"] ?? void 0}}

pms_OneVsRestClassifier_partial_fit = {k: v for k, v in pms_OneVsRestClassifier_partial_fit.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_partial_fit = bridgeOneVsRestClassifier[${this.id}].partial_fit(**pms_OneVsRestClassifier_partial_fit)`;
    return this._py`res_OneVsRestClassifier_partial_fit.tolist() if hasattr(res_OneVsRestClassifier_partial_fit, 'tolist') else res_OneVsRestClassifier_partial_fit`;
  }
  /**
    Predict multi-class targets using underlying estimators.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsRestClassifier must call init() before predict()");
    }
    await this._py.ex`pms_OneVsRestClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsRestClassifier_predict = {k: v for k, v in pms_OneVsRestClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_predict = bridgeOneVsRestClassifier[${this.id}].predict(**pms_OneVsRestClassifier_predict)`;
    return this._py`res_OneVsRestClassifier_predict.tolist() if hasattr(res_OneVsRestClassifier_predict, 'tolist') else res_OneVsRestClassifier_predict`;
  }
  /**
      Probability estimates.
  
      The returned estimates for all classes are ordered by label of classes.
  
      Note that in the multilabel case, each sample can have any number of labels. This returns the marginal probability that the given sample has the label in question. For example, it is entirely consistent that two labels both have a 90% probability of applying to a given sample.
  
      In the single label multiclass case, the rows of the returned matrix sum to 1.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_OneVsRestClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OneVsRestClassifier_predict_proba = {k: v for k, v in pms_OneVsRestClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_predict_proba = bridgeOneVsRestClassifier[${this.id}].predict_proba(**pms_OneVsRestClassifier_predict_proba)`;
    return this._py`res_OneVsRestClassifier_predict_proba.tolist() if hasattr(res_OneVsRestClassifier_predict_proba, 'tolist') else res_OneVsRestClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OneVsRestClassifier must call init() before score()");
    }
    await this._py.ex`pms_OneVsRestClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OneVsRestClassifier_score = {k: v for k, v in pms_OneVsRestClassifier_score.items() if v is not None}`;
    await this._py.ex`res_OneVsRestClassifier_score = bridgeOneVsRestClassifier[${this.id}].score(**pms_OneVsRestClassifier_score)`;
    return this._py`res_OneVsRestClassifier_score.tolist() if hasattr(res_OneVsRestClassifier_score, 'tolist') else res_OneVsRestClassifier_score`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_estimators_ = bridgeOneVsRestClassifier[${this.id}].estimators_`;
      return this._py`attr_OneVsRestClassifier_estimators_.tolist() if hasattr(attr_OneVsRestClassifier_estimators_, 'tolist') else attr_OneVsRestClassifier_estimators_`;
    })();
  }
  /**
    Class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_classes_ = bridgeOneVsRestClassifier[${this.id}].classes_`;
      return this._py`attr_OneVsRestClassifier_classes_.tolist() if hasattr(attr_OneVsRestClassifier_classes_, 'tolist') else attr_OneVsRestClassifier_classes_`;
    })();
  }
  /**
    Object used to transform multiclass labels to binary labels and vice-versa.
   */
  get label_binarizer_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing label_binarizer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_label_binarizer_ = bridgeOneVsRestClassifier[${this.id}].label_binarizer_`;
      return this._py`attr_OneVsRestClassifier_label_binarizer_.tolist() if hasattr(attr_OneVsRestClassifier_label_binarizer_, 'tolist') else attr_OneVsRestClassifier_label_binarizer_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_n_features_in_ = bridgeOneVsRestClassifier[${this.id}].n_features_in_`;
      return this._py`attr_OneVsRestClassifier_n_features_in_.tolist() if hasattr(attr_OneVsRestClassifier_n_features_in_, 'tolist') else attr_OneVsRestClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OneVsRestClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OneVsRestClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OneVsRestClassifier_feature_names_in_ = bridgeOneVsRestClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_OneVsRestClassifier_feature_names_in_.tolist() if hasattr(attr_OneVsRestClassifier_feature_names_in_, 'tolist') else attr_OneVsRestClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/multiclass/OutputCodeClassifier.ts
import crypto3 from "node:crypto";
var OutputCodeClassifier = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `OutputCodeClassifier${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "OutputCodeClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.multiclass import OutputCodeClassifier
try: bridgeOutputCodeClassifier
except NameError: bridgeOutputCodeClassifier = {}
`;
    await this._py.ex`ctor_OutputCodeClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'code_size': ${this.opts["code_size"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OutputCodeClassifier = {k: v for k, v in ctor_OutputCodeClassifier.items() if v is not None}`;
    await this._py.ex`bridgeOutputCodeClassifier[${this.id}] = OutputCodeClassifier(**ctor_OutputCodeClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOutputCodeClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit underlying estimators.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OutputCodeClassifier must call init() before fit()");
    }
    await this._py.ex`pms_OutputCodeClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_OutputCodeClassifier_fit = {k: v for k, v in pms_OutputCodeClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_fit = bridgeOutputCodeClassifier[${this.id}].fit(**pms_OutputCodeClassifier_fit)`;
    return this._py`res_OutputCodeClassifier_fit.tolist() if hasattr(res_OutputCodeClassifier_fit, 'tolist') else res_OutputCodeClassifier_fit`;
  }
  /**
    Predict multi-class targets using underlying estimators.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OutputCodeClassifier must call init() before predict()");
    }
    await this._py.ex`pms_OutputCodeClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OutputCodeClassifier_predict = {k: v for k, v in pms_OutputCodeClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_predict = bridgeOutputCodeClassifier[${this.id}].predict(**pms_OutputCodeClassifier_predict)`;
    return this._py`res_OutputCodeClassifier_predict.tolist() if hasattr(res_OutputCodeClassifier_predict, 'tolist') else res_OutputCodeClassifier_predict`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("OutputCodeClassifier must call init() before score()");
    }
    await this._py.ex`pms_OutputCodeClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_OutputCodeClassifier_score = {k: v for k, v in pms_OutputCodeClassifier_score.items() if v is not None}`;
    await this._py.ex`res_OutputCodeClassifier_score = bridgeOutputCodeClassifier[${this.id}].score(**pms_OutputCodeClassifier_score)`;
    return this._py`res_OutputCodeClassifier_score.tolist() if hasattr(res_OutputCodeClassifier_score, 'tolist') else res_OutputCodeClassifier_score`;
  }
  /**
    Estimators used for predictions.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_estimators_ = bridgeOutputCodeClassifier[${this.id}].estimators_`;
      return this._py`attr_OutputCodeClassifier_estimators_.tolist() if hasattr(attr_OutputCodeClassifier_estimators_, 'tolist') else attr_OutputCodeClassifier_estimators_`;
    })();
  }
  /**
    Array containing labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_classes_ = bridgeOutputCodeClassifier[${this.id}].classes_`;
      return this._py`attr_OutputCodeClassifier_classes_.tolist() if hasattr(attr_OutputCodeClassifier_classes_, 'tolist') else attr_OutputCodeClassifier_classes_`;
    })();
  }
  /**
    Binary array containing the code of each class.
   */
  get code_book_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing code_book_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_code_book_ = bridgeOutputCodeClassifier[${this.id}].code_book_`;
      return this._py`attr_OutputCodeClassifier_code_book_.tolist() if hasattr(attr_OutputCodeClassifier_code_book_, 'tolist') else attr_OutputCodeClassifier_code_book_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_n_features_in_ = bridgeOutputCodeClassifier[${this.id}].n_features_in_`;
      return this._py`attr_OutputCodeClassifier_n_features_in_.tolist() if hasattr(attr_OutputCodeClassifier_n_features_in_, 'tolist') else attr_OutputCodeClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This OutputCodeClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "OutputCodeClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OutputCodeClassifier_feature_names_in_ = bridgeOutputCodeClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_OutputCodeClassifier_feature_names_in_.tolist() if hasattr(attr_OutputCodeClassifier_feature_names_in_, 'tolist') else attr_OutputCodeClassifier_feature_names_in_`;
    })();
  }
};
export {
  OneVsOneClassifier,
  OneVsRestClassifier,
  OutputCodeClassifier
};
//# sourceMappingURL=index.js.map